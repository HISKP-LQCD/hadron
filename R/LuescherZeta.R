## interface function for the C implementation of Lueschers Zeta function



#' Computes Lueschers Zeta Function
#' 
#' Implementation of Lueschers Zeta Function for general \code{l}, \code{m} and
#' boost vectors \code{dvec}.
#' 
#' The Zeta function is evaluated following arXiv:1107.5023. The evaluation is
#' implemented in C using GSL routines.
#' 
#' @param qsq a vector containing the squared scattering momenta to evaluate
#' the Zeta function on
#' @param l the angular momentum quantum number l
#' @param m the angular momentum quantum number m
#' @param dvec integer vector with three elements indicating the total momentum
#' @param gamma boost factor
#' @param lambda cut-off parameter for the integration
#' @param tol error tolerance in numerical integrations
#' @param verbose makes the function (very much) more verbose
#' @return a vector of complex values of the same length as \code{qsq}
#' containing the value of the Zeta function
#' @author Carsten Urbach, \email{curbach@@gmx.de}, Zahnlin Wang,
#' \email{wangzhanlin@@hiskp.uni-bonn.de}
#' @references See arXiv:1107.5023
#' @examples
#' 
#'   LuescherZeta(c(0.1, 0.2))
#'   ## next center of mass example
#'   Pcm <- c(0, 0, 0)
#'   q <- 0.1207*24/(2.*pi)
#'   gamma <- 1.0
#'   zeta <- Re(LuescherZeta(q^2, gamma = gamma, dvec = Pcm))
#'   delta <- atan2(pi^(3./2.)*q,zeta)*180./pi
#'   cat("delta = ", delta, "to compare with 136.6527\n")
#' 
#'   ## moving frame example
#'   Pcm <- c(0, 0, 1)
#'   L <- 32
#'   q <- 0.161*L/(2.*pi)
#'   E <- 0.440
#'   Ecm <- 0.396
#'   gamma <- E/Ecm
#'   Z00 = Re(LuescherZeta(q^2, gamma=gamma, dvec = Pcm))
#'   Z20 = Re(LuescherZeta(q^2, gamma=gamma, dvec = Pcm, l = 2))
#'   delta = atan2(gamma*pi**(3./2.) * q , (Z00 + (2./(q*q*sqrt(5)))*Z20))*180./pi
#'   cat("delta = ", delta, "to compare with 115.7653\n")
#' 
#'   ## moving frame 2
#'   Pcm <- c(1, 1, 0)
#'   L <- 32
#'   q <- 0.167*L/(2.*pi)
#'   E <- 0.490
#'   Ecm <- 0.407
#'   gamma <- E/Ecm
#'   Z00 <- Re(LuescherZeta(q^2, gamma=gamma, dvec = Pcm))
#'   Z20 <- Re(LuescherZeta(q^2, gamma=gamma, dvec = Pcm, l = 2))
#'   Z22  <- Im(LuescherZeta(q^2, gamma=gamma, dvec = Pcm, l = 2, m = 2))
#'   Z2_2 <- Im(LuescherZeta(q^2, gamma=gamma, dvec = Pcm, l = 2, m = -2))
#'   delta <- atan2(gamma*pi^(3./2.) * q , (Z00 - (1./(q^2*sqrt(5)))*Z20 +
#'         ((sqrt(3./10.)/(q^2))*(Z22-Z2_2))))*180./pi
#'   cat("delta = ", delta, "to compare with 127.9882\n")
#' 
#' 
#' @export LuescherZeta
LuescherZeta <- function(qsq, l=0, m=0, dvec=c(0,0,0), gamma=1, lambda=1, tol=0.000001, verbose=FALSE) {
  if(!is.numeric(qsq) || !is.numeric(l) || !is.numeric(m) || !is.numeric(dvec) || !is.numeric(gamma) || !is.numeric(lambda) || !is.numeric(tol))
    stop("argument qsq to LuescherZeta must be numeric!\n")
  n <- length(qsq)
  if(length(gamma) == 1) {
    gamma <- rep(gamma, times=n)
  }
  if(n != length(gamma)) {
    stop("gamma must be either a scalar or a vector of length identical with the length of qsq\n")
  }
  verb <- 0
  if(verbose) verb <- 1
  return(.Call("LuscherZetaArray", as.double(qsq), as.integer(n), as.integer(l[1]), as.integer(m[1]), as.double(dvec[1:3]), as.double(gamma), as.double(lambda[1]), as.double(tol), as.integer(verb)))
}
