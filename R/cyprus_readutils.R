#' @title HDF5 key for Cyprus CalcLoops scalar-type loops
#' @description Generates an HDF5 key (full path) for the scalar
#'              type loops from the Cyprus CalcLoops application.
#' @param istoch Integer, index of the stochastic sample that the key should
#'               be generated for.
#' @param loop_type String, name of loop type. Allowed values:
#'                  'Scalar', 'dOp'
#' @param cid Integer, configuration number, internally produced by the CalcLoops
#'            tool via the "trajectory" input flag. The default is '4' as this is
#'            often not used in practice.
cyprus_make_key_scalar <- function(istoch, loop_type, cid = 4){
  if( any( !(loop_type %in% c("Scalar","dOp","Naive")) ) ){
    stop("The only scalar loop types are 'Scalar', 'Naive' and 'dOp'")
  }
  return(sprintf("/conf_%04d/Nstoch_%04d/%s/loop",
                 cid, istoch, loop_type)
        )
}


#' @title HDF5 key for Cyprus CalcLoops derivative-type loops
#' @description Generates an HDF5 key (full path) for the derivative
#'              type loops from the Cyprus CalcLoops application.
#' @param istoch Integer, index of the stochastic sample that the key should
#'               be generated for.
#' @param loop_type String, name of loop type. Allowed values:
#'                  'Loops', 'LpsDw', 'LpsDwCv', 'LoopsCv'
#' @param dir Integer, lattice direction of the derivative. Allowed values:
#'            \code{0 == x}, \code{1 == y}, \code{2 == z}, \code{3 == t}.
#' @param cid Integer, configuration number, internally produced by the CalcLoops
#'            tool via the "trajectory" input flag. The default is '4' as this is
#'            often not used in practice.
cyprus_make_key_deriv <- function(istoch, loop_type, dir, cid = 4){
  deriv_loop_types <- c("LpsDw", "Loops", "LpsDwCv", "LoopsCv")
  if( any( !(loop_type %in% deriv_loop_types ) ) ) {
    stop(sprintf("The only derivative loop types are %s",
                 do.call(paste, list(deriv_loop_types))
                 )
        )
  }
  stopifnot( dir %in% c(0:3) )
  return(sprintf("/conf_%04d/Nstoch_%04d/%s/dir_%02d/loop",
                 cid, istoch, loop_type, dir))
}


#' @title HDF5 key for Cyprus Calc2pt-and Calc2pt-3pt baryon contractions
#' @description Generates an HDF5 key (full path) for the baryon 2pt -3pt 
#'              correlation function produced by plegma postprocessed by 
#'              extract2.py python filtering routine
#'              (one usually filters out some momentum combinations)
#'              and merge.py python merge routine (one merges all the 
#'              source position and gauge configuration). 
#'           
#' @param type_of_correlation_function twopt or threept
#'              generated by PLEGMA
#' @param confnumber String, index of the gauge field configuration
#' 
#' @param source_location String, sx??sy??sz??st??? format string that 
#'              contains the position o
#'      
#' @param baryon_type String that charachterizes the type of the baryon
#'              DeltaMn, Delta0, DeltaPl, DeltaPlPl 
#'
#' @param interpolator_type: String that determines the type of the 
#'               interpolator: Comes from PLEGMA, possible values
#                Pp_Cgi_Cgi
cyprus_make_key_baryon <- function( type_of_correlation_function, confnumber, source_location, baryon_type, interpolator_type ){

  return (sprintf("/%s/%s/%s/%s/%s", type_of_correlation_function,
                                                                confnumber,
                                                                source_location,
                                                                baryon_type,
                                                                interpolator_type))
}


#' @title read HDF5 loop files in the Cyprus CalcLoops format
#' @description The CalcLoops code produces HDF5 files which contain
#'              a matrix of momenta and the data for the loops (without
#'              spin projection) organised by stochastic sample. Currently, the
#'              reading code assumes that there is a single configuration stored per
#'              file and the "trajectory" parameter in CalcLoops is assumed
#'              to take its default value of '4'.
#' @param selections Named list with names from the list 'Naive', 'Scalar', 'dOp', 'Loops'
#'                   'LpsDw', 'LpsDwCv', 'LoopsCv' specifying the requesetd loop types. 
#'                   The elements of this list are in turn expected
#'                   be data frames of the form
#'                     \tabular{rrr}{
#'                       \strong{qx} \tab \strong{qy} \tab \strong{qz} \cr
#'                       0           \tab 0           \tab 1           \cr
#'                       -2          \tab 1           \tab -3          \cr
#'                       ...         \tab ...         \tab ...
#'                     }
#'                   specifying the momentum combinations to be extracted for each
#'                   loop type.
#' @param files Vector of strings, list of HDF5 files to be processed.
#' @param Time Integer, time extent of the lattice.
#' @param nstoch Integer, number of stochastic samples to be expected in file.
#' @param accumulated Boolean, specifies whether the loops, as organised by stochastic sample,
#'                    are accumulated, such that, say, element \code{n} corresponds to the 
#'                    sum over the first \code{n} stochastic samples. If specified as \code{TRUE},
#'                    the data is post-processed to recover the measurements for the particular
#'                    samples.
#' @param legecy_traj Boolean. The root group for the loop data is 'conf_xxxx', where 'xxxx'
#'                    corresponds to what is passed via the 'traj' flag to CalcLoops. When
#'                    left empty, this defaults to '0004'. If this was left emtpy when
#'                    the loop files were generated, set this to \code{TRUE} and the paths
#'                    will be constructed with 'conf_0004' as their root group.
#' @param verbose Boolean, output I/O time per file. Requires 'tictoc' package.
#' @return Named nested list of the same length as \code{selections} containg the loop data
#'         in the \link{raw_cf} format. Each named element corresponds to one loop
#'         type and each element of the underlying numbered list corresponds to one momentum
#'         combination as specified via \code{selections} for this loop type in the same order.
#'         
#' @export
cyprus_read_loops <- function(selections, files, Time, nstoch, accumulated = TRUE, legacy_traj = TRUE, verbose = FALSE){
  rhdf5_avail <- requireNamespace("rhdf5")
  dplyr_avail <- requireNamespace("dplyr")
  if( !rhdf5_avail | !dplyr_avail ){
    stop("The 'dplyr' and 'rhdf5' packages are required to use this function!\n")
  }
  if( verbose ){
    tictoc_avail <- requireNamespace("tictoc")
    if( !tictoc_avail ){
      stop("Time reporting requires the 'tictoc' package!")
    }
  }

  rval <- list()
  selected_loop_types <- names(selections)

  if( any( !(selected_loop_types %in% c("Scalar", "dOp", "Naive") ) ) ){
    stop("Currently only 'Scalar', 'dOp' and 'Naive' loop types are supported!")
  }

  for( ifile in 1:length(files) ){
    f <- files[ifile]
    if(verbose) tictoc::tic(sprintf("Reading %s",f))
    
    # The file names are of the form 
    # path/MG_loop_FLAVORquark_conf_conf.XXXX_runtype_probD8_part1_stoch_NeV0_NsYYYY_step0001_QsqZZ.h5
    # and we want to recover XXXX
    tokens <- unlist(strsplit(basename(f), split = ".", fixed = TRUE))
    cid_in_filename <- as.integer(strsplit(tokens, split = "_", fixed = TRUE)[[2]][1])

    if( legacy_traj ){
      cid_to_read <- 4
    } else {
      cid_to_read <- cid_in_filename
    }

    h5f <- rhdf5::H5Fopen(f, flags = "H5F_ACC_RDONLY")
    
    group_names <- h5ls(h5f)$name
    
    avail_loop_types <- unlist( lapply( selected_loop_types, function(x){ x %in% group_names } ) )
    if( any( !avail_loop_types ) ){
      msg <- sprintf("Some selected loop types could not be found in %s:\n %s",
                     f,
                     do.call(paste, as.list( selected_loop_types[!avail_loop_types] ) )
                     )
      stop(msg)
    }
    if( !H5Lexists(h5f, "Momenta_list_xyz") ){
      stop(sprintf("'Momenta_list_xyz' could not be found in %s!", f))
    }
    # we transpose this to get the momenta as the rows of a matrix
    momenta_avail <- as.data.frame(t(h5_get_dataset(h5f, "Momenta_list_xyz")))
    colnames(momenta_avail) <- c("qx","qy","qz")
    # index the momentum combinations
    momenta_avail <- cbind(momenta_avail, idx = 1:nrow(momenta_avail))

    # how many stochastic samples are available and does it match out expectation?
    stoch_avail <- sort(as.numeric(unlist(lapply(X = strsplit(unique(group_names[ grepl("Nstoch", group_names) ]),
                                       "_"),
                                 FUN = function(x){ x[2] })
                          )))
    if( length(stoch_avail) != nstoch ){
      stop(sprintf("Number of stochastic samples in file %s :\n%d, expected %d!",
                   f, length(stoch_avail), nstoch))
    }

    # check if there are multiple instances of 'conf_xxxx' group names
    # in the file
    if( length( unique( group_names[ grepl("conf", group_names) ] ) ) > 1 ){
      warning(sprintf(paste("The file\n%s\ncontains more than one 'conf_xxxx'",
                            "group names.\nThis is currently not really supported,",
                            "but we will continue and attempt to read 'conf_%04d' (and no others!)"),
                      f, cid_to_read),
              immediate. = TRUE)
    }
    for( loop_type in selected_loop_types ){
      # check if all the momenta that we want are in the file
      # we do this per loop_type as we could have different selections
      # for different loop types
      missing_momenta <- dplyr::anti_join(x = selections[[ loop_type ]],
                                          y = momenta_avail,
                                          by = c("qx","qy","qz"))
      if( nrow(missing_momenta) > 0 ){
        msg <- sprintf("\nMomenta\n%s\ncould not be found in %s!",
                      do.call(paste,
                              list(...=apply(X = missing_momenta,
                                             MARGIN = 1,
                                             FUN = function(x){
                                                 sprintf("(%d,%d,%d)", x[1], x[2], x[3])
                                               }
                                           ),
                                    sep = '\n'
                                  )
                              ),
                      f
                      )
        stop(msg)
      }
      # select which elements we need to read
      selected_momenta <- dplyr::inner_join(x = selections[[ loop_type ]],
                                            y = momenta_avail,
                                            by = c("qx","qy","qz"))

      for( istoch in 1:nstoch ){
        key <- cyprus_make_key_scalar(istoch = istoch,
                                      loop_type = loop_type,
                                      cid = cid_to_read)

        # read the data, which comes in the ordering
        #   complex, gamma, mom_idx, time
        # we permute it to
        #   time, gamma, complex, mom_idx
        # this is quite expensive, but it makes filling the target
        # array much easier below
        # Note that 'gamma' is of length 16
        data <- h5_get_dataset(h5f, key)
        # first we select the momenta that we actually want
        data <- data[,,selected_momenta$idx,,drop=FALSE]
        # and then perform the reshaping on this (possibly) reduced array
        data <- aperm(data,
                      perm = c(4,2,1,3))
        dims <- dim(data)
        nts <- dims[1]

        if( !(loop_type %in% names(rval) ) ){
          rval[[ loop_type ]] <- list()
        }
        for( mom_idx in 1:nrow(selected_momenta) ){
          if( length(rval[[ loop_type ]]) < mom_idx ){
            rval[[loop_type]][[mom_idx]] <- array(as.complex(NA), dim=c(length(files),
                                                                        nts,
                                                                        length(stoch_avail),
                                                                        4,
                                                                        4)
                                                  )
          }
          rval[[loop_type]][[mom_idx]][ifile, 1:nts, istoch, 1:4, 1:4] <-
            complex(real = data[1:nts, 1:16, 1, mom_idx ],
                    imaginary = data[1:nts, 1:16, 2, mom_idx ])
        }
      } # istoch
    } # loop_type
    H5Fclose(h5f)
    if(verbose) tictoc::toc()
  } # ifile
  for( loop_type in selected_loop_types ){
    # recover measurements from individual stochastic samples
    if( accumulated ){
      for( mom_idx in 1:nrow(selected_momenta) ){
        temp <- rval[[loop_type]][[mom_idx]]
        for( istoch in 2:nstoch ){
          rval[[loop_type]][[mom_idx]][,,istoch,,] <- temp[,,istoch,,] - temp[,,(istoch-1),,]
        }
      }
    }
    # finally make `raw_cf` objects
    for( mom_idx in 1:nrow(selected_momenta) ){
      rval[[loop_type]][[mom_idx]] <- 
        raw_cf_data(raw_cf_meta(Time = Time,
                                nrObs = 1,
                                nrStypes = 1,
                                dim = c(length(stoch_avail), 4, 4),
                                nts = nts),
                    data = rval[[loop_type]][[mom_idx]])
    }
  }
  return(rval)
}
#' @export
#' @title read HDF5 contraction files in the Cyprus Calc2pt-3pt format
#' @description The Calc2pt function produces all types of baryon 2 and 3 pt
#'              functions for different momentum interpolating operators,  
#'              and source positions.
#'
#'              In this routine we read the types of baryon contractions 
#'              specified by selections.
#'              For the moment here you can only define the type
#'              of interpolators and the type of correlation function
#'              currently the routine also assumes that all the datasets
#'              for different configurations, different source positions, etc.
#'              are merged together in one hdf5 file.
#'              The list of gauge congfigurations and source positions does
#'              not have to be specified.
#'              i.e we read all available data from the hdf5 file.
#'              Currently the routine only reads one momentum
#'
#' @param selections Named list with names from the list 'DeltaMn','Delta0',etc.
#'                   The elements of this list are in turn expected
#'                   be data frames of the form
#'                     \tabular{rr}{
#'                       \strong{interp} \tab \strong{type} \cr
#'                       "Cgi_Cgi"    \tab "twop"        \cr
#'                       "Cgi_Cgig0"  \tab "twop"        \cr
#'                       ...             \tab ...         
#'                     }
#'                   specifying the interpolating operators and contractions types
#'                   for each baryon type.
#' @param symmetrize bool space time reflection symmetries of the action and the 
#'                        anti periodic boundary conditions in the temporal direction 
#'                        for the quark field at zero momentum imply, C_x^+(t)=-C_x^{-}(T-t)
#'                        in order to decrease errors we average correlators in the forward 
#'                        backward direction and define
#'                        C_x(t)=C_x^+(t)-C_x^-(T-t)
#' @param files Vector of strings, list of HDF5 files to be processed.
#'                    Currently only one element supported
#' @param Time Integer, time extent of the lattice.
#' @param verbose Boolean, output I/O time per file. Requires 'tictoc' package.
#' @return 
#'         raw_cf object containing all the correlation functions.
#'         Find it useful temporary for using the gevp
#' @export
cyprus_read_baryon_correlation <- function(selections, files, symmetrize, Time, verbose = FALSE){
  rhdf5_avail <- requireNamespace("rhdf5")
  dplyr_avail <- requireNamespace("dplyr")
  if( !rhdf5_avail | !dplyr_avail ){
    stop("The 'dplyr' and 'rhdf5' packages are required to use this function!\n")
  }
  if( verbose ){
    tictoc_avail <- requireNamespace("tictoc")
    if( !tictoc_avail ){
      stop("Time reporting requires the 'tictoc' package!")
    }
  }
 
  selected_baryon_types <- names(selections)

  for( ifile in 1:length(files) ){
    f <- files[ifile]
    if(verbose) tictoc::tic(sprintf("Reading %s",f))    

    # Extracting the type of the correlation function we want possibility twop , threep, we extract all other information from the hd5f file
    # for now we have only real support for the twop case
    type_of_correlation_function <- as.vector(selections[[baryon_type]]$type)[1]


    h5f <- rhdf5::H5Fopen(f, flags = "H5F_ACC_RDONLY")
    #First we extract the configuration id-s
    temporary1 <- rhdf5::h5ls(h5f)
    filtering_patter <- sprintf("%s/....", type_of_correlation_function)
    temporary2 <- unique(temporary1$group %>% str_extract(pattern=filtering_pattern))
    gauge_conf_list <- temporary2[!is.na(temporary2)] 


    #checking whether the wanted baryon type is available in the file
    avail_baryon_types <- unlist( lapply( selected_baryon_types, function(x){ x %in% temporary1$name } ) )
    if( any( !avail_baryon_types ) ){
        msg <- sprintf("Some selected baryon types could not be found in %s:\n %s",
                       f,
                       do.call(paste, as.list( selected_baryon_types[!avail_baryon_types] ) )
                     )
        stop(msg)
    }

    interpolator_list_length <- length(selections[[ baryon_type ]]$interp)

    # In case we symmetrize the correlator we do not store separately
    # the plus and minus projection, and we store the timeslices only
    # from 1 to Time/2+1
    if (symmetrize == TRUE){

      final_val <- array(as.complex(NA), dim=c(length(gauge_conf_list), length(selected_baryon_types)*interpolator_list_length*(Time/2+1)))

    }
    # On the other hand if we do not symmetrize we store the plus
    # and minus correlator separately for the full time extent
    else{
      final_val <- array(as.complex(NA), dim=c(length(gauge_conf_list), length(selected_baryon_types)*2*interpolator_list_length*Time))
    }
    for (gauges in gauge_conf_list){

    #we wanted to extract all source position for a given config

      splitting_pattern <- sprintf("%s/", type_of_correlation_function)
      configstring <- unlist(strsplit(gauges, split = splitting_pattern, fixed = TRUE))[[2]]
      temporary1 <- rhdf5::h5ls(h5f)
      temporary1 <- temporary1$group[grepl(configstring,temporary1$group)]
      temporary2 <- unique(temporary1 %>% str_extract(pattern="sx..sy..sz..st..."))
      source_position_list <- temporary2[!is.na(temporary2)]

      
      for( baryon_type in selected_baryon_types ){

         
        for(interp in selections[[ baryon_type ]]$interp){ 

          if (symmetrize == TRUE){

            rval <- array(as.complex(NA), dim=c(length(source_position_list),
                                                                        Time/2+1                                                 ))
          }
          else {
            rval1 <- array(as.complex(NA), dim=c(length(source_position_list),
                                                                        Time                                                 ))
            rval2 <- array(as.complex(NA), dim=c(length(source_position_list),
                                                                        Time                                                 ))

          }
          for (sp in source_position_list){

            #Reading the positive
            interp_pp <- sprintf("Pp_%s", interp)

            key <- cyprus_make_key_baryon( as.vector(selections[[baryon_type]]$type)[1], configstring, sp, baryon_type, interp_pp )

            # read the data, which comes in the ordering
            # time, complex
            data_pp <- h5_get_dataset(h5f, key)
            #rval[which(sp==source_position_list),1:Time] <- complex(real=data[1,1:Time], imaginary=data[2,1:Time])

            #Reading the negative
            intern_pm <- sprintf("Pm_%s", interp)
            key <- cyprus_make_key_baryon( as.vector(selections[[baryon_type]]$type)[1], configstring, sp, baryon_type, interp_pm )

            # read the data, which comes in the ordering
            # time, complex
            data_pm <- h5_get_dataset(h5f, key)
             
            if (symmetrize == TRUE){

              reversed <- data_pm[,ncol(data_pm):1]
              for (line in 2:(Time/2+1)){
                data_pp[,line] <- data_pp[,line]-data_pm[,line-1]
              }
              rval[which(sp==source_position_list),1:(Time/2+1)] <- complex(real=data[1,1:(Time/2+1)], imaginary=data[2,1:(Time/2+1)])

            }
            else{
              rval1[which(sp==source_position_list),1:Time] <- complex(real=data_pp[1,1:Time], imaginary=data_pp[2,1:Time])
              rval2[which(sp==source_position_list),1:Time] <- complex(real=data_pm[1,1:Time], imaginary=data_pm[2,1:Time])

            }
          } # source_positions 
          str(rval)
          if (symmetrize == TRUE){

            for (nt in 1:Time/2+1){
              tmpr <- 0
              tmpi <- 0
              for (line in 1:length(source_position_list)){

                tmpr <- tmpr + Re(rval[line,nt])
                tmpi <- tmpi + Im(rval[line,nt])

              }
              tmpr <- tmpr/ length(source_position_list)
              tmpi <- tmpi/ length(source_position_list)

              final_val[which(gauges==gauge_conf_list),(Time/2+1)*interpolator_list_length*(which(baryon_type==selected_baryon_types)-1)+(Time/2+1)*(which(interp==selections[[ baryon_type ]]$interp)-1)+nt] <- complex(real=tmpr, imaginary=tmpi)

            }

          }
          else{
            for (nt in 1:Time){
              tmpr <- 0 
              tmpi <- 0
              for (line in 1:length(source_position_list)){

                tmpr <- tmpr + Re(rval1[line,nt])
                tmpi <- tmpi + Im(rval1[line,nt])

              }
              tmpr <- tmpr/ length(source_position_list)
              tmpi <- tmpi/ length(source_position_list) 

              final_val[which(gauges==gauge_conf_list),2*Time*interpolator_list_length*(which(baryon_type==selected_baryon_types)-1)+2*Time*(which(interp==selections[[ baryon_type ]]$interp)-1)+nt] <- complex(real=tmpr, imaginary=tmpi)

              tmpr <- 0
              tmpi <- 0
              for (line in 1:length(source_position_list)){

                tmpr <- tmpr + Re(rval2[line,nt])
                tmpi <- tmpi + Im(rval2[line,nt])

              }
              tmpr <- tmpr/ length(source_position_list)
              tmpi <- tmpi/ length(source_position_list)

              final_val[which(gauges==gauge_conf_list),Time*2*interpolator_list_length*(which(baryon_type==selected_baryon_types)-1)+2*Time*(which(interp==selections[[ baryon_type ]]$interp)-1)+Time+nt] <- complex(real=tmpr, imaginary=tmpi)

            }# time
          } #symmetrize
        } # interpolating operators
      } # baryon type
    } # gauge conf
    str(final_val)
    H5Fclose(h5f)
    if(verbose) tictoc::toc()
  } # ifile


  # finally make `raw_cf` objects
  rval <- raw_cf_data(
            raw_cf_meta(Time = Time,
                        nrObs = 1,
                        nrStypes= 1),
                        data=final_val
                        )
  return(rval)
}
