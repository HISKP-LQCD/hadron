#u' @title HDF5 key for Cyprus CalcLoops scalar-type loops
#' @description Generates an HDF5 key (full path) for the scalar
#'              type loops from the Cyprus CalcLoops application.
#' @param istoch Integer, index of the stochastic sample that the key should
#'               be generated for.
#' @param loop_type String, name of loop type. Allowed values:
#'                  'Scalar', 'dOp'
#' @param cid Integer, configuration number, internally produced by the CalcLoops
#'            tool via the "trajectory" input flag. The default is '4' as this is
#'            often not used in practice.
#' @param accumulated Boolean, depending on whether the loop data was accumulated
#'                    over the stochastic source d.o.f. or not, the keys are
#'                    different. Default: FALSE
#' @export
cyprus_make_key_scalar <- function(istoch, loop_type, cid = 4, accumulated = FALSE){
  if( any( !(loop_type %in% c("Scalar","dOp","Naive")) ) ){
    stop("The only scalar loop types are 'Scalar', 'Naive' and 'dOp'")
  }

  nchar <- "n"
  if( accumulated ){ nchar <- "N" }

  return(sprintf("/conf_%04d/%sstoch_%04d/%s/loop",
                 cid, nchar, istoch, loop_type)
        )
}


#' @title HDF5 key for Cyprus CalcLoops derivative-type loops
#' @description Generates an HDF5 key (full path) for the derivative
#'              type loops from the Cyprus CalcLoops application.
#' @param istoch Integer, index of the stochastic sample that the key should
#'               be generated for.
#' @param loop_type String, name of loop type. Allowed values:
#'                  'Loops', 'LpsDw', 'LpsDwCv', 'LoopsCv'
#' @param dir Integer, lattice direction of the derivative. Allowed values:
#'            \code{0 == x}, \code{1 == y}, \code{2 == z}, \code{3 == t}.
#' @param cid Integer, configuration number, internally produced by the CalcLoops
#'            tool via the "trajectory" input flag. The default is '4' as this is
#'            often not used in practice.
#' @param accumulated Boolean, depending on whether the loop data was accumulated
#'                    over the stochastic source d.o.f. or not, the keys are
#'                    different. Default: FALSE
#' @export
cyprus_make_key_vector <- function(istoch, loop_type, dir, cid = 4, accumulated = FALSE){
  vector_loop_types <- c("LpsDw", "Loops", "LpsDwCv", "LoopsCv")
  if( any( !(loop_type %in% vector_loop_types ) ) ) {
    stop(sprintf("The only derivative loop types are %s",
                 do.call(paste, list(vector_loop_types))
                 )
        )
  }
  stopifnot( dir %in% c(0:3) )

  nchar <- "n"
  if( accumulated ){ nchar <- "N" }

  return(sprintf("/conf_%04d/%sstoch_%04d/%s/dir_%02d/loop",
                 cid, nchar, istoch, loop_type, dir))
}



#' @title HDF5 key for Cyprus Calc2pt-and Calc2pt-3pt baryon contractions
#' @description Generates an HDF5 key (full path) for the baryon 2pt -3pt 
#'              correlation function produced by plegma postprocessed by 
#'              extract2.py python filtering routine
#'              (one usually filters out some momentum combinations)
#'              and merge.py python merge routine (one merges all the 
#'              source position and gauge configuration). 
#'           
#' @param type_of_correlation_function twopt or threept
#'              generated by PLEGMA
#' @param confnumber String, index of the gauge field configuration
#' 
#' @param source_location String, sx??sy??sz??st??? format string that 
#'              contains the position o
#'      
#' @param baryon_type String that charachterizes the type of the baryon
#'              DeltaMn, Delta0, DeltaPl, DeltaPlPl 
#'
#' @param interpolator_type: String that determines the type of the 
#'               interpolator: Comes from PLEGMA, possible values
#                Pp_Cgi_Cgi
#cyprus_make_key_baryon <- function( type_of_correlation_function, confnumber, source_location, baryon_type, interpolator_type ){

#  return (sprintf("/%s/%s/%s/%s/%s", type_of_correlation_function,
#                                                                confnumber,
#                                                                source_location,
#                                                                baryon_type,
#                                                                interpolator_type))
#}
#/0280_SS_gN50a4p_aN50a0p5/sx09sy15sz18st37/baryons_u[+2.5e-03]d[-2.5e-03]s[+1.5e-02]/OmegaMn/Pp_Cgi_Cgi Dataset {64}

cyprus_make_key_baryon <- function( type_of_correlation_function, smearing_type, baryon_building_blocks, confnumber, source_location, baryon_type, interpolator_type ){

  return (sprintf("/%s_%s_%s/%s/%s/%s/%s", confnumber,
                                           type_of_correlation_function, 
                                           smearing_type,
                                           source_location,
                                           baryon_building_blocks,
                                           baryon_type,
                                           interpolator_type))
}

#' @title HDF5 key for Cyprus piNdiagramms- 2pt baryon contractions
#' @description Generates an HDF5 key (full path) for the baryon 2pt
#'              Generated by the piNdiagramms executable
#'              The key encodes the type of the baryon and the source 
#'              position, note that no more post-processing is needed,
#'              the correlation function is already shifted relativ to the
#'              source. 
#'           
#' @param type_of_baryon twopt it can be D or N
#' 
#' @param source_location String, sx??sy??sz??st??? format string that 
#'              contains the position o
cyprus_make_key_scattering2pt <- function( source_location, type_of_baryon ){

  return (sprintf("%s/%s",source_location,
                           type_of_baryon))
}


#' @title HDF5 key for Cyprus piNdiagramms- 4pt baryon contractions
#' @description Generates an HDF5 key (full path) for the baryon 2pt
#'              Generated by the piNdiagramms executable
#'              The key encodes the type of the contraction (B,W,Z), the
#'              source position for the point source propagator and the 
#'              momentum in the sequential propagators
#'           
#' @param type_of_correlation can be B1,B2,W1,W2,W3,W4,Z1,Z2,Z3,Z4
#' 
#' @param source_location String, sx??sy??sz??st??? format string 
#'
#' @param momentum string specifying the momentum in the sequential 
#'        propagator for example: pi2=1_-1_1
cyprus_make_key_scattering4pt <- function( source_location, momentum_i2, type_of_correlation ){

  return (sprintf("%s/pi2=%d_%d_%d/%s",source_location,
                             momentum_i2[1],momentum_i2[2],momentum_i2[3],
                             type_of_correlation))
}



#' @title read HDF5 loop files in the Cyprus CalcLoops format
#' @description The CalcLoops code produces HDF5 files which contain
#'              a matrix of momenta and the data for the loops (without
#'              spin projection) organised by stochastic sample. Currently, the
#'              reading code assumes that there is a single configuration stored per
#'              file.
#' @param selections Named list with names from the list 'Naive', 'Scalar', 'dOp', 'Loops'
#'                   'LpsDw', 'LpsDwCv', 'LoopsCv' specifying the requesetd loop types. 
#'                   The elements of this list are in turn expected
#'                   be data frames of the form
#'                     \tabular{rrr}{
#'                       \strong{px} \tab \strong{py} \tab \strong{pz} \cr
#'                       0           \tab 0           \tab 1           \cr
#'                       -2          \tab 1           \tab -3          \cr
#'                       ...         \tab ...         \tab ...
#'                     }
#'                   specifying the momentum combinations to be extracted for each
#'                   loop type.
#' @param files Vector of strings, list of HDF5 files to be processed.
#' @param Time Integer, time extent of the lattice.
#' @param nstoch Integer, number of stochastic samples to be expected in file.
#' @param accumulated Boolean or vector of boolean, specifies whether the loops, 
#'                    as organised by stochastic sample,
#'                    are accumulated, such that, say, element \code{n} corresponds to the 
#'                    sum over the first \code{n} stochastic samples. If specified as \code{TRUE},
#'                    the data is post-processed to recover the measurements for the particular
#'                    samples. In case this is specified as a vector, it must be of the same
#'                    length as \code{files}. Default: TRUE.
#' @param legacy_traj Boolean. The root group for the loop data is 'conf_xxxx', where 'xxxx'
#'                    corresponds to what is passed via the 'traj' flag to CalcLoops. When
#'                    left empty, this defaults to '0004'. If this was left emtpy when
#'                    the loop files were generated, set this to \code{TRUE} and the paths
#'                    will be constructed with 'conf_0004' as their root group. 
#'                    When specified as a vector, it must be of length \code{length(files)}
#'                    giving the integer configuration indices, such as \code{c(0, 2, 4, 6)}
#'                    Default: TRUE.
#' @param verbose Boolean, output I/O time per file. Requires 'tictoc' package. Default FALSE.
#' @param check_group_names Boolean, employ \code{rhdf5::h5ls} to check if all the group names
#'                          that we want to read are actually in the file. This can be slow
#'                          for large files. Default: FALSE.
#' @param spin_project Boolean, whether the loops should be spin projected after being read.
#'                     Must be provided to together with \code{project_gamma}! Default: FALSE
#' @param project_gamma Named list of the same length as \code{selections} containing, for each
#'                      selected loop type a 4x4 complex-valued projection matrix. For vector
#'                      loop types, one matrix must be provided per direction (so \code{project_gamma$loop_type}
#'                      is a numbered list with indices \code{c(1,2,3,4)}. Default: NULL
#' @param use_parallel Boolean, whether to parallelise over the files using the `mclapply` from the `parallel`
#'                     package.
#' @return Named nested list of the same length as \code{selections} containg the loop data
#'         in the \link{raw_cf} format. Each named element corresponds to one loop
#'         type.
#'         For scalar-valued loop types, each element of the underlying numbered list
#'         corresponds to one momentum combination as specified via \code{selections} 
#'         for this loop type in the same order.
#'         For the vector-valued loop types, the first level of the underlying numbered
#'         list has four elements corresponding to the four derivative directions 
#'         in the order t,x,y,z.
#'         At the next level, the underlying numbered list corresponds to the momentum
#'         combinations for this loop type and derivative direction, just as for the
#'         scalar type.
#'         
#' @export
cyprus_read_loops <- function(selections, files, Time, nstoch,
                              accumulated = TRUE,
                              legacy_traj = TRUE, 
                              verbose = FALSE,
                              check_group_names = FALSE,
                              spin_project = FALSE,
                              project_gamma = NULL,
                              use_parallel = TRUE){
  rhdf5_avail <- requireNamespace("rhdf5")
  dplyr_avail <- requireNamespace("dplyr")
  if( !rhdf5_avail | !dplyr_avail ){
    stop("The 'dplyr' and 'rhdf5' packages are required to use this function!\n")
  }

  if( verbose ){
    tictoc_avail <- requireNamespace("tictoc")
    if( !tictoc_avail ){
      stop("Time reporting (verbose = TRUE) requires the 'tictoc' package!")
    }
  }
  if( use_parallel ){
    parallel_avail <- requireNamespace("parallel")
    if( !parallel_avail ){
      stop("Running in parallel requires the 'parallel' package!")
    }
    lapply_fn <- parallel::mclapply
  } else {
    lapply_fn <- lapply
  }

  files_not_exist <- unlist(lapply(X = files,
                                   FUN = 
                                     function(x){
                                       !file.exists(x)
                                     }
                                   )
                           )
  if( any( files_not_exist ) ){
    cat("The files: ", files[files_not_exist], " do not exist! \n")
    stop("There were missing files!")
  }
 
  # we require 'accumulated' and 'legacy_traj' to be vectors below
  # so if only one value was passed, replicate these here
  if( length(accumulated) == 1 ){
    accumulated <- rep(x = accumulated,
                       times = length(files))
  }
  if( length(legacy_traj) == 1 ){
    legacy_traj <- rep(x = legacy_traj,
                       times = length(files))
  }

  scalar_loop_types <- c("Scalar", "dOp", "Naive")
  vector_loop_types <- c("Loops", "LpsDw", "LpsDwCv", "LoopsCv")
  supported_loop_types <- c(scalar_loop_types, vector_loop_types)

  rval <- list()
  selected_loop_types <- names(selections)

  if( any( !(selected_loop_types %in% supported_loop_types ) ) ){
    invalid_loop_types <- 
      selected_loop_types[ !(selected_loop_types %in% supported_loop_types)]
    args <- lapply(X=1:length(invalid_loop_types), FUN=function(x){ invalid_loop_types[x] })
    args$sep <- ", "
    stop(sprintf("Loop types '%s' are not supported!",
                do.call(paste, args)))
  }

  # if we want to spin project, projection gamma matrices should be provided
  # for all selected loop types
  if( spin_project ){
    stopifnot( !is.null(project_gamma) )
    stopifnot( all( names(selections) == names(project_gamma) ) )
    selected_vec_loop_types <- which( names(selections) %in% vector_loop_types )
    incorrectly_sized_projectors <- NULL
    for( loop_type in selected_vec_loop_types ){
      if( length(project_gamma[[loop_type]] != 4) ){
        incorrectly_sized_projectors <- c(incorrectly_sized_projectors, loop_type)
      }
    }
    if( length(incorrectly_sized_projectors) > 0 ){
      stop(sprintf("'project_gamma' for loop types '%s' were not of the right length!",
                   do.call(paste, incorrectly_sized_projectors)
                   )
          )
    }
    
    # when spin-projecting, we pre-allocate an internal dimension of 1x1
    internal_dim <- 1
  } else {
    # otherwise, we pre-allocate 4x4 matrices internally
    internal_dim <- 4
  }

  loops_per_file <- lapply_fn(
    X = 1:length(files),
    FUN = function(ifile){
      f <- files[ifile]
      if(verbose){
        cat(sprintf("Opening %s\n",f))
        tictoc::tic("Loop extraction")
      }

      # our output for this file
      this_file_loops <- list()
      
      # The file names are of the form 
      # path/MG_loop_FLAVORquark_conf_conf.XXXX_runtype_probD8_part1_stoch_NeV0_NsYYYY_step0001_QsqZZ.h5
      # and we want to recover XXXX
      tokens <- unlist(strsplit(basename(f), split = ".", fixed = TRUE))
      cid_in_filename <- as.integer(strsplit(tokens, split = "_", fixed = TRUE)[[2]][1])

      # In the generation of loop files via CalcLoops in the "flavour singlet" project running
      # on PizDaint from Oct. 2018 - Oct. 2019, there was an issue with the naming of
      # the "trajectory" group name in the HDF5 files. If files were affected,
      # the stored "trajectory" id was always "4" instead of the actual configuration number.
      if( legacy_traj[ifile] ){
        cid_to_read <- 4
      } else {
        cid_to_read <- cid_in_filename
      }

      h5f <- rhdf5::H5Fopen(f, flags = "H5F_ACC_RDONLY")
   
      if( check_group_names ){ 
        group_names <- rhdf5::h5ls(h5f)$name

        # are all requested loop types really available?
        avail_loop_types <- unlist( lapply( selected_loop_types, function(x){ x %in% group_names } ) )
        if( any( !avail_loop_types ) ){
          msg <- sprintf("Some selected loop types could not be found in %s:\n %s",
                         f,
                         do.call(paste, as.list( selected_loop_types[!avail_loop_types] ) )
                         )
          stop(msg)
        }
        # how many stochastic samples are available and does it match our expectation?
        if( accumulated[ifile] ){
          stoch_text <- "Nstoch"
        } else {
          stoch_text <- "nstoch"
        }
        stoch_avail <- sort(as.numeric(
                         unlist(
                            lapply(X = strsplit(unique(group_names[ grepl(stoch_text, group_names) ]), "_"),
                                   FUN = function(x){ x[2] })
                          )
                       ))
        if( length(stoch_avail) != nstoch ){
          stop(sprintf("Number of stochastic samples in file %s :\n%d, expected %d!",
                       f, length(stoch_avail), nstoch))
        }

        # check if there are multiple instances of 'conf_xxxx' group names
        # in the file
        if( length( unique( group_names[ grepl("conf", group_names) ] ) ) > 1 ){
          warning(sprintf(paste("The file\n%s\ncontains more than one 'conf_xxxx'",
                                "group names.\nThis is currently not really supported,",
                                "but we will continue and attempt to read 'conf_%04d' (and no others!)"),
                          f, cid_to_read),
                  immediate. = TRUE)
        }
      } # if(check_group_names)

      if( !rhdf5::H5Lexists(h5f, "Momenta_list_xyz") ){
        stop(sprintf("'Momenta_list_xyz' could not be found in %s!", f))
      }
      # we transpose this to get the momenta as the rows of a matrix
      momenta_avail <- as.data.frame(t(h5_get_dataset(h5f, "Momenta_list_xyz")))
      colnames(momenta_avail) <- c("px","py","pz")
      # index the momentum combinations
      momenta_avail <- cbind(momenta_avail, idx = 1:nrow(momenta_avail))

      for( loop_type in selected_loop_types ){
        # check if all the momenta that we want are in the file
        # we do this per loop_type as we could have different selections
        # for different loop types
        missing_momenta <- dplyr::anti_join(x = selections[[ loop_type ]],
                                            y = momenta_avail,
                                            by = c("px","py","pz"))
        if( nrow(missing_momenta) > 0 ){
          msg <- sprintf("\nMomenta\n%s\ncould not be found in %s!",
                        do.call(paste,
                                list(...=apply(X = missing_momenta,
                                               MARGIN = 1,
                                               FUN = function(x){
                                                   sprintf("(%d,%d,%d)", x[1], x[2], x[3])
                                                 }
                                             ),
                                      sep = '\n'
                                    )
                                ),
                        f
                        )
          stop(msg)
        }
        # select which elements we need to read from the available momenta
        # this fixes the set of momenta_avail$idx which are going to be processed
        selected_momenta <- dplyr::inner_join(x = selections[[ loop_type ]],
                                              y = momenta_avail,
                                              by = c("px","py","pz"))

        for( istoch in 1:nstoch ){
          if( loop_type %in% scalar_loop_types ){
            key <- cyprus_make_key_scalar(istoch = istoch,
                                          loop_type = loop_type,
                                          cid = cid_to_read,
                                          accumulated = accumulated[ifile])

            # read the data, which comes in the ordering
            #   complex, gamma, mom_idx, time
            # we permute it to
            #   time, gamma, complex, mom_idx
            # this is quite expensive, but it makes filling the target
            # array much easier below
            # Note that 'gamma' is of length 16
            data <- h5_get_dataset(h5f, key)
            # first we select the momenta that we actually want
            data <- data[,,selected_momenta$idx,,drop=FALSE]
            # and then perform the reshaping on this (possibly) reduced array
            data <- aperm(data, perm = c(4,2,1,3))
            dims <- dim(data)
            nts <- dims[1]

            if( nts != Time ){
              stop(sprintf("For %s, the number of time slices %d does not match the expected time extent %d!",
                           key, nts, Time))
            }

            if( !(loop_type %in% names(this_file_loops) ) ){
              this_file_loops[[ loop_type ]] <- list()
            }
            for( mom_idx in 1:nrow(selected_momenta) ){
              # if the list element corresponding to 'mom_idx' is empty,
              # we pre-allocate some space for an array there
              # note that the first dimension is of size 1, we will concatenate over this dimension
              # after all files have been read
              if( length(this_file_loops[[ loop_type ]]) < mom_idx ){
                this_file_loops[[loop_type]][[mom_idx]] <- 
                  array(as.complex(NA), dim=c(1,
                                              Time,
                                              nstoch,
                                              internal_dim,
                                              internal_dim)
                                             )
              }
              # in order to make spin projection easier, we create an intermediate raw_cf object
              # with a single measurement
              temp_raw_cf <- raw_cf_data(raw_cf_meta(Time = Time,
                                                     nrObs = 1,
                                                     nrStypes = 1,
                                                     dim = c(1, 4, 4),
                                                     nts = Time),
                                         data = array(complex(real = data[1:Time, 1:16, 1, mom_idx ],
                                                              imaginary = data[1:Time, 1:16, 2, mom_idx ]),
                                                      dim = c(1, Time, 1, 4, 4)))
              if(spin_project){
                temp_raw_cf <- loop_spin_project(loop = temp_raw_cf,
                                                 gamma = project_gamma[[loop_type]])
              }
              # and now we extract the data into our pre-allocated tensor again
              # further below, the entire tensor will be turned back into raw_cf
              # This is wasteful, but allows us to reuse loop_spin_project here
              this_file_loops[[loop_type]][[mom_idx]][1, 1:Time, istoch, 1:internal_dim, 1:internal_dim] <-
                temp_raw_cf$data
            }
          } else if( loop_type %in% vector_loop_types ){
            if( !(loop_type %in% names(this_file_loops) ) ){
              this_file_loops[[loop_type]] <- list()
            }
            if( length(this_file_loops[[loop_type]]) == 0 ){
              for( dir_idx in 1:4 ){
                this_file_loops[[loop_type]][[dir_idx]] <- list()
              }
            }
            # we are going to interchange t <-> x as direction 0 below
            deriv_dirs_out <- c(1,2,3,0)
            for( deriv_dir_in in c(0,1,2,3) ){
              key <- cyprus_make_key_vector(istoch = istoch,
                                            loop_type = loop_type,
                                            dir = deriv_dir_in,
                                            cid = cid_to_read,
                                            accumulated = accumulated[ifile])

              # read the data, which comes in the ordering
              #   complex, gamma, mom_idx, time
              # we permute it to
              #   time, gamma, complex, mom_idx
              # this is quite expensive, but it makes filling the target
              # array much easier below
              # Note that 'gamma' is of length 16
              data <- h5_get_dataset(h5f, key)
              # first we select the momenta that we actually want
              data <- data[,,selected_momenta$idx,,drop=FALSE]
              # and then perform the reshaping on this (possibly) reduced array
              data <- aperm(data, perm = c(4,2,1,3))
              dims <- dim(data)
              nts <- dims[1]
            
              if( nts != Time ){
                stop(sprintf("For %s, the number of time slices %d does not match the expected time extent %d!",
                             key, nts, Time))
              }

              # we interchange t <-> x as direction 0
              # and assign an idx in 1:4 -> (t,1),(x,2),(y,3),(z,4) 
              deriv_dir_out_idx <- deriv_dirs_out[ deriv_dir_in+1 ]+1
              for( mom_idx in 1:nrow(selected_momenta) ){
                if( length(this_file_loops[[loop_type]][[deriv_dir_out_idx]]) < mom_idx ){
                  this_file_loops[[loop_type]][[deriv_dir_out_idx]][[mom_idx]] <- 
                    array(as.complex(NA), dim=c(1,
                                                Time,
                                                nstoch,
                                                internal_dim,
                                                internal_dim)
                          )
                }
                # in order to make spin projection easier, we create an intermediate raw_cf object
                # with a single measurement
                temp_raw_cf <- raw_cf_data(raw_cf_meta(Time = Time,
                                                       nrObs = 1,
                                                       nrStypes = 1,
                                                       dim = c(1, 4, 4),
                                                       nts = Time),
                                           data = array(complex(real = data[1:Time, 1:16, 1, mom_idx ],
                                                                imaginary = data[1:Time, 1:16, 2, mom_idx ]),
                                                        dim = c(1,Time,1,4,4)))
                if(spin_project){
                  temp_raw_cf <- loop_spin_project(loop = temp_raw_cf,
                                                   gamma = project_gamma[[loop_type]][[deriv_dir_out_idx]])
                }
                # And now we extract the data into our pre-allocated tensor again
                # further below, the entire tensor will be turned back into raw_cf
                # This is wasteful, but allows us to reuse loop_spin_project here
                this_file_loops[[loop_type]][[deriv_dir_out_idx]][[mom_idx]][1, 1:Time, istoch, 1:internal_dim, 1:internal_dim] <-
                  temp_raw_cf$data
              } # for(mom_idx)
            } # for(deriv_dir_in)
          } # if(loop_type)
        } # for(istoch)
      } # for(loop_type)
      rhdf5::H5Fclose(h5f)

      # if the current file was produced in the "accumulated" convention -> de-accumulate it
      if( accumulated[ifile] ){
        for( loop_type in selected_loop_types ){
          # recover measurements from individual stochastic samples
            for( mom_idx in 1:nrow(selected_momenta) ){
              if( loop_type %in% scalar_loop_types ){
                temp <- this_file_loops[[loop_type]][[mom_idx]]
                for( istoch in 2:nstoch ){
                  this_file_loops[[loop_type]][[mom_idx]][1,,istoch,,] <- temp[1,,istoch,,] - temp[1,,(istoch-1),,]
                }
              } else if( loop_type %in% vector_loop_types ){
                # for the vector-valued loop types we need to duplicate some code
                for( dir_idx in 1:4 ){
                  temp <- this_file_loops[[loop_type]][[dir_idx]][[mom_idx]]
                  for( istoch in 2:nstoch ){
                    this_file_loops[[loop_type]][[dir_idx]][[mom_idx]][1,,istoch,,] <- temp[1,,istoch,,] - temp[1,,(istoch-1),,]
                  }
                } # for(dir_idx)
              } # if(loop_type)
            } # for(mom_idx) 
          } # for(selected_loop_types)
      } # if(accumulated)

      if(verbose) tictoc::toc()
      return(this_file_loops)
    } # FUN(ifile)
  ) # lapply

  # this is our final return value for which we will now collect the loop data
  # from all files, converting it to raw_cf in the process
  rval <- list()
  for( loop_type in selected_loop_types ){
    rval[[loop_type]] <- list()
    if( loop_type %in% scalar_loop_types ){
      for( mom_idx in 1:nrow(selections[[loop_type]]) ){
        temp <- array(as.complex(NA), dim=c(length(files),
                                            Time,
                                            nstoch,
                                            internal_dim,
                                            internal_dim)
                      )
        for( ifile in 1:length(files) ){
          temp[ifile, , , , ] <- 
            loops_per_file[[ifile]][[loop_type]][[mom_idx]][1, , , , ]
        }
        rval[[ loop_type ]][[ mom_idx ]] <-
          raw_cf_data(raw_cf_meta(Time = Time,
                                  nrObs = 1,
                                  nrStypes = 1,
                                  dim = c(nstoch, internal_dim, internal_dim),
                                  nts = Time),
                      data = temp)
        
      }
      # and the same for the vector loop types
    } else if( loop_type %in% vector_loop_types ) { 
      for( dir_idx in 1:4 ){
        rval[[loop_type]][[dir_idx]] <- list()
        for( mom_idx in 1:nrow(selections[[loop_type]][[dir_idx]]) ){
          temp <- array(as.complex(NA), dim=c(length(files),
                                              Time,
                                              nstoch,
                                              internal_dim,
                                              internal_dim)
                        )
          for( ifile in 1:length(files) ){
            temp[ifile, , , , ] <- 
              loops_per_file[[ifile]][[loop_type]][[dir_idx]][[mom_idx]][1, , , , ]
          }
          rval[[loop_type]][[dir_idx]][[mom_idx]] <- 
            raw_cf_data(raw_cf_meta(Time = Time,
                                    nrObs = 1,
                                    nrStypes = 1,
                                    dim = c(nstoch, internal_dim, internal_dim),
                                    nts = Time),
                        data = temp)
        } # for(mom_idx)
      } # for(dir_idx)
    } # if( loop_type )
  } # for( loop_type )
  return(rval)
}
#' @export
#' @title read HDF5 contraction files in the Cyprus Calc2pt-3pt format
#' @description The Calc2pt function produces all types of baryon 2 and 3 pt
#'              functions for different momentum interpolating operators,  
#'              and source positions.
#'
#'              In this routine we read the types of baryon contractions 
#'              specified by selections.
#'              For the moment here you can only define the type
#'              of interpolators and the type of correlation function
#'              currently the routine also assumes that all the datasets
#'              for different configurations, different source positions, etc.
#'              are merged together in one hdf5 file.
#'              The list of gauge congfigurations and source positions does
#'              not have to be specified.
#'              i.e we read all available data from the hdf5 file.
#'              Currently the routine only reads one momentum
#'
#' @param selections Named list with names from the list 'DeltaMn','Delta0',etc.
#'                   The elements of this list are in turn expected
#'                   be data frames of the form
#'                     \tabular{rr}{
#'                       \strong{interp} \tab \strong{type} \cr
#'                       "Cgi_Cgi"    \tab "twop"        \cr
#'                       "Cgi_Cgig0"  \tab "twop"        \cr
#'                       ...             \tab ...         
#'                     }
#'                   specifying the interpolating operators and contractions types
#'                   for each baryon type.
#' @param symmetrize bool space time reflection symmetries of the action and the 
#'                        anti periodic boundary conditions in the temporal direction 
#'                        for the quark field at zero momentum imply, C_x^+(t)=-C_x^{-}(T-t)
#'                        in order to decrease errors we average correlators in the forward 
#'                        backward direction and define
#'                        C_x(t)=C_x^+(t)-C_x^-(T-t)
#' @param files Vector of strings, list of HDF5 files to be processed.
#'                    Currently only one element supported
#' @param Time Integer, time extent of the lattice.
#' @param verbose Boolean, output I/O time per file. Requires 'tictoc' package.
#' @return 
#'         raw_cf object containing all the correlation functions.
#'         Find it useful temporary for using the gevp

#' @export
cyprus_read_baryon_correlation <- function(selections, files, symmetrize, Time, verbose = FALSE){
  rhdf5_avail <- requireNamespace("rhdf5")
  dplyr_avail <- requireNamespace("dplyr")
  stringr_avail <- requireNamespace("stringr")
  if( !rhdf5_avail | !dplyr_avail | !stringr_avail){
    stop("The 'dplyr', 'stringr'  and 'rhdf5' packages are required to use this function!\n")
  }
  if( verbose ){
    tictoc_avail <- requireNamespace("tictoc")
    if( !tictoc_avail ){
      stop("Time reporting requires the 'tictoc' package!")
    }
  }
 
  selected_baryon_types <- names(selections)

  for( ifile in 1:length(files) ){
    f <- files[ifile]
    if(verbose) tictoc::tic(sprintf("Reading %s",f))    
    print(files[ifile])
    h5f <- rhdf5::H5Fopen(f, flags = "H5F_ACC_RDONLY")
    #First we extract the configuration id-s
    temporary1 <- rhdf5::h5ls(h5f)

    # Extracting the type of the correlation function we want possibility twop , threep, we extract all other information from the hd5f file
    # for now we have only real support for the twop case


    #checking whether the wanted baryon type is available in the file
    avail_baryon_types <- unlist( lapply( selected_baryon_types, function(x){ x %in% temporary1$name } ) )
    if( any( !avail_baryon_types ) ){
        msg <- sprintf("Some selected baryon types could not be found in %s:\n %s",
                       f,
                       do.call(paste, as.list( selected_baryon_types[!avail_baryon_types] ) )
                     )
        stop(msg)
    }

    type_of_correlation_function <- as.vector(selections[[avail_baryon_types[1]]]$type)[1]


    filtering_pattern <- sprintf("/....", type_of_correlation_function)
    temporary2 <- unique(temporary1$group %>% str_extract(pattern=filtering_pattern))
    gauge_conf_list <- temporary2[!is.na(temporary2)] 


    interpolator_list_length <- length(selections[[avail_baryon_types[1]]]$interp)

    # In case we symmetrize the correlator we do not store separately
    # the plus and minus projection, and we store the timeslices only
    # from 1 to Time/2+1
    if (symmetrize == TRUE){

      final_val <- array(as.complex(NA), dim=c(length(gauge_conf_list), length(selected_baryon_types)*interpolator_list_length*(Time/2+1)))

    }
    # On the other hand if we do not symmetrize we store the plus
    # and minus correlator separately for the full time extent
    else{
      final_val <- array(as.complex(NA), dim=c(length(gauge_conf_list), length(selected_baryon_types)*2*interpolator_list_length*Time))
    }
    for (gauges in gauge_conf_list){
      print(gauges)

    #we wanted to extract all source position for a given config

      splitting_pattern <- sprintf("/")
      configstring <- unlist(strsplit(gauges, split = splitting_pattern, fixed = TRUE))[[2]]
      temporary1 <- rhdf5::h5ls(h5f)
      temporary1 <- temporary1$group[grepl(configstring,temporary1$group)]
      temporary2 <- unique(temporary1 %>% str_extract(pattern="sx..sy..sz..st..."))
      source_position_list <- temporary2[!is.na(temporary2)]

      
      for( baryon_type in selected_baryon_types ){

         
        for(interp in selections[[ baryon_type ]]$interp){ 

          if (symmetrize == TRUE){

            rval <- array(as.complex(NA), dim=c(length(source_position_list),
                                                                        Time/2+1                                                 ))
          }
          else {
            rval1 <- array(as.complex(NA), dim=c(length(source_position_list),
                                                                        Time                                                 ))
            rval2 <- array(as.complex(NA), dim=c(length(source_position_list),
                                                                        Time                                                 ))

          }
          for (sp in source_position_list){

            #Reading the positive
            interp_pp <- sprintf("Pp_%s", interp)

            key <- cyprus_make_key_baryon( as.vector(selections[[baryon_type]]$type)[1], as.vector(selections[[baryon_type]]$smearing_type)[1], as.vector(selections[[baryon_type]]$baryon_building_blocks)[1], configstring, sp, baryon_type, interp_pp )

            # read the data, which comes in the ordering
            # time, complex
            data_pp <- h5_get_dataset(h5f, key)
            #rval[which(sp==source_position_list),1:Time] <- complex(real=data[1,1:Time], imaginary=data[2,1:Time])

            #Reading the negative
            interp_pm <- sprintf("Pm_%s", interp)
            key <- cyprus_make_key_baryon( as.vector(selections[[baryon_type]]$type)[1], as.vector(selections[[baryon_type]]$smearing_type)[1], as.vector(selections[[baryon_type]]$baryon_building_blocks)[1], configstring, sp, baryon_type, interp_pm )

            # read the data, which comes in the ordering
            # time, complex
            data_pm <- h5_get_dataset(h5f, key)
             
            if (symmetrize == TRUE){
              if (length(dim(data_pm))==1){
                 reversed <- data_pm[nrow(data_pm):1]
              } else { reversed <- data_pm[,ncol(data_pm):1] }
              
              for (line in 2:(Time/2+1)){
                if (length(dim(data_pm))==1){
                         data_pp[line] <- data_pp[line]-reversed[line-1]
                } else { data_pp[,line] <- data_pp[,line]-reversed[,line-1] }
              }
              if (length(dim(data_pm))==1){
                        rval[which(sp==source_position_list),1:(Time/2+1)] <- complex(real=data_pp[1:(Time/2+1)], imaginary=rep(0,length(data_pp[1:(Time/2+1)])))
              } else  { rval[which(sp==source_position_list),1:(Time/2+1)] <- complex(real=data_pp[1,1:(Time/2+1)], imaginary=data_pp[2,1:(Time/2+1)]) }
            } else{
              if (length(dim(data_pm))==1){
                rval1[which(sp==source_position_list),1:Time] <- complex(real=data_pp[1:Time], imaginary=rep(length(data_pp[1:Time])))
                rval2[which(sp==source_position_list),1:Time] <- complex(real=data_pm[1:Time], imaginary=rep(length(data_pm[1:Time]))) 
              } else {
                rval1[which(sp==source_position_list),1:Time] <- complex(real=data_pp[1,1:Time], imaginary=data_pp[2,1:Time])
                rval2[which(sp==source_position_list),1:Time] <- complex(real=data_pm[1,1:Time], imaginary=data_pm[2,1:Time])    }

            }
          } # source_positions 
          if (symmetrize == TRUE){

            for (nt in 1:Time/2+1){
              tmpr <- 0
              tmpi <- 0
              for (line in 1:length(source_position_list)){

                tmpr <- tmpr + Re(rval[line,nt])
                tmpi <- tmpi + Im(rval[line,nt])

              }
              tmpr <- tmpr/ length(source_position_list)
              tmpi <- tmpi/ length(source_position_list)

              final_val[which(gauges==gauge_conf_list),(Time/2+1)*interpolator_list_length*(which(baryon_type==selected_baryon_types)-1)+(Time/2+1)*(which(interp==selections[[ baryon_type ]]$interp)-1)+nt] <- complex(real=tmpr, imaginary=tmpi)

            }

          }
          else{
            for (nt in 1:Time){
              tmpr <- 0 
              tmpi <- 0
              for (line in 1:length(source_position_list)){

                tmpr <- tmpr + Re(rval1[line,nt])
                tmpi <- tmpi + Im(rval1[line,nt])

              }
              tmpr <- tmpr/ length(source_position_list)
              tmpi <- tmpi/ length(source_position_list) 

              final_val[which(gauges==gauge_conf_list),2*Time*interpolator_list_length*(which(baryon_type==selected_baryon_types)-1)+2*Time*(which(interp==selections[[ baryon_type ]]$interp)-1)+nt] <- complex(real=tmpr, imaginary=tmpi)

              tmpr <- 0
              tmpi <- 0
              for (line in 1:length(source_position_list)){

                tmpr <- tmpr + Re(rval2[line,nt])
                tmpi <- tmpi + Im(rval2[line,nt])

              }
              tmpr <- tmpr/ length(source_position_list)
              tmpi <- tmpi/ length(source_position_list)

              final_val[which(gauges==gauge_conf_list),Time*2*interpolator_list_length*(which(baryon_type==selected_baryon_types)-1)+2*Time*(which(interp==selections[[ baryon_type ]]$interp)-1)+Time+nt] <- complex(real=tmpr, imaginary=tmpi)

            }# time
          } #symmetrize
        } # interpolating operators
      } # baryon type
    } # gauge conf
    str(final_val)
    H5Fclose(h5f)
    if(verbose) tictoc::toc()
  } # ifile

  return(final_val)

  # finally make cf objects
  cf <- cf_meta(nrObs=1,Time=Time,nrStypes=1)
  cf <- cf_orig(cf, cf=Re(final_val),icf=Im(final_val))
  if (symmetrize == TRUE){ 
    cf$symmetrised <- TRUE
  }
  return(invisible(cf))
}
#' @export
#' @title read HDF5 unprojected contraction files in the Cyprus piNdiagramms format
#' @description The piNdiagramms function produces all types of baryon
#'              correlation function for isospin 3/2  for different momentum 
#               combinations, interpolating operators and source positions.
#'
#'              In this routine we read the types of baryon contractions 
#'              specified by selections.
#'              For the moment here you can only define the 
#'                     a;type of baryon (N,D)
#'                     b;gamma structures (Cg1,Cg2,Cg2)
#'                     c;momentum (0,0,0)
#' @param selections Named list with names from the list 'D','N'
#'                   The elements of this list are in turn expected
#'                   be data frames of the form
#'                     \tabular{rrrr}{
#'                       \strong{interp} \tab \strong{px} \tab \strong{py} \tab \stron{pz} \cr
#'                       "Cg1,Cg2,Cg3"  \tab "0" \tab "1" \tab "1" \cr
#'                       "Cg1,Cg2,Cg3"  \tab "0" \tab "1" \tab "0" \cr
#'                       ...        \tab ... \tab ... \tab ...         
#'                     }
#'                   specifying the interpolating operators and momenta 
#'                   for each baryon type.
#' @param files Vector of strings, list of HDF5 files to be processed.
#'                    Currently only one element supported
#' @param Time Integer, time extent of the lattice.
#' @param verbose Boolean, output I/O time per file. Requires 'tictoc' package.
#' @return 
#'         raw_cf object containing all the correlation functions.
#'         Find it useful temporary for using the gevp

#' @export
cyprus_read_scattering_2pt_correlation <- function(selections, files, Time, verbose = FALSE){
  rhdf5_avail <- requireNamespace("rhdf5")
  dplyr_avail <- requireNamespace("dplyr")
  if( verbose ){
    tictoc_avail <- requireNamespace("tictoc")
    if( !tictoc_avail ){
      stop("Time reporting requires the 'tictoc' package!")
    }
  }

  selected_baryon_types <- names(selections)

  #we store the real parts and imaginary parts for
  #the different source positions separately
  data_final_real <- NULL
  data_final_imag <- NULL

  #loop on the list of files provided in the input
  for( ifile in 1:length(files) ){
    f <- files[ifile]
    if(verbose) tictoc::tic(sprintf("Reading %s",f))

    #open the file with read only argument
    h5f <- rhdf5::H5Fopen(f, flags = "H5F_ACC_RDONLY")

    #checking whether the wanted baryon type is available in the file
    temporary1 <- rhdf5::h5ls(h5f)
    avail_baryon_types <- unlist( lapply( selected_baryon_types, function(x){ x %in% temporary1$name } ) )
    if( any( !avail_baryon_types ) ){
        msg <- sprintf("Some selected baryon types could not be found in %s:\n %s",
                       f,
                       do.call(paste, as.list( selected_baryon_types[!avail_baryon_types] ) )
                     )
        stop(msg)
    }

    #First we extract the source positions contained in the file
    h5filedatasetcontent <- rhdf5::h5ls(h5f)
    #loop over all the source positions in the file, 
    #for each sourceposition we write out seperately "mvec" dataset
    #that is the reason for the division by 2
    for (sourceposition in 1:((length(h5filedatasetcontent$group)-1)/2)){

      key <- cyprus_make_key_scattering2pt( h5filedatasetcontent$group[2*sourceposition], "mvec" )

      # read the available momenta
      # array of 3 integer number
      data_mom <- h5_get_dataset(h5f, key)
       
      key <- cyprus_make_key_scattering2pt( h5filedatasetcontent$group[2*sourceposition], selected_baryon_types )

      # read the data
      data_corr <- h5_get_dataset(h5f, key)
      # convert it to a two-dimensional format, in such a way
      # that the first index corresponds to the gauge configuration (and source position)
      # and the second index corresponds to everything else
      #res <- matrix(data_corr, prod(dim(data_corr)[1:3]),dim(data_corr)[5])
      dim(data_corr)<- c(2,16,prod(dim(data_corr))/32/Time,Time) 



      #looking for the momentum combinations
      #filtering out the momentum
      final_indices <- NULL
      for (differentcombinations in 1: length(selections[[avail_baryon_types]]$interp)){

        #determining the indices of momentum
        for(mom in 1:ncol(data_mom)){ 
          if (all.equal(data_mom[,mom], 
                              c(selections[[selected_baryon_types]]$px[differentcombinations],
                                selections[[selected_baryon_types]]$py[differentcombinations],
                                selections[[selected_baryon_types]]$pz[differentcombinations]))==TRUE){
            momindex <- mom
            break;
          } 
        }
        #getting the available gamma structures
        descrip <- rhdf5::h5readAttributes(h5f,key,"description")
        tmp <- strsplit(descrip$description,"/")
        tmp1<- strsplit(tmp[[1]][[4]],"}")
        tmp2 <- gsub(",\\{","",tmp1[[1]][[3]])
        gamma_source_list <- strsplit(tmp2,",")[[1]]
        gammalist <- strsplit(as.character(selections[[selected_baryon_types]]$interp[differentcombinations]),",")[[1]]

        #Determining the indices of the gamma structures
        indices <- NULL
        error_gamma <- TRUE
        for (line in 1:length(gammalist)){
          for (line2 in 1:length(gamma_source_list)){
            if (all.equal(gammalist[line], gamma_source_list[line2])==TRUE){
              indices <- c(indices,line2);
              error_gamma <- FALSE
              break;
            }
          }
        }
        #if we have a gamma structure in the input that cannot be found in the
        # hdf5 file we return with error message
        if( error_gamma == TRUE ){
          msg <- sprintf("Some selected gamma structures could not be found in %s:\n %s",
                       f,
                       do.call(paste, as.list( gamma_source_list ) )
                     )
          stop(msg)
        }

        #Determining the indices of all the correlation functions
        #for example if the input is cg1,cg2,cg3 then we need the following
        #matrix
        #c( (cg1,cg1)  (cg1,cg2) (cg1,cg3) )
        #c( (cg2,cg1)  (cg2,cg2) (cg2,cg3) )
        #c( (cg3,cg1)  (cg3,cg2) (cg3,cg3) )
        #Note that here we do not project out, we return all the spin components
        #with real and imaginary part

        for (line1 in 1:length(indices)){
          for (line2 in 1:length(indices)){
            final_indices <- c(final_indices, (momindex-1)*length(gamma_source_list)*length(gamma_source_list)+(indices[line1]-1)*length(gamma_source_list)+(indices[line2]))
          }
        }        
      }
      data_unprojected<- data_corr[,,final_indices,]
      #Doing possible spin projection
      data_projection <- data_unprojected

      #Doing the symmetrization
      #C+-B=<0.25*Tr(1+-g4)*C>
      #Csymmetried=C+B(t)-C-B(T-t)


      partial_array<- array(0,dim=c(2,Time/2+1,length(final_indices)))

      #Obtaining C(T-t)

      #if we filter out just one gammastructure and momentum, then
      #data_projection will be not 4 but three dimensional structure
      #therefore we have do an if statement here
      if (length(final_indices)==1){
        reversed <- data_projection[,,Time:1]

        partial_array[,1,] <- 0.25*(data_projection[,1,1]+data_projection[,6,1])
        for (line in 2:(Time/2+1)){
          partial_array[,line,] <- 0.25*(data_projection[,1,line]+data_projection[,6,line])
          partial_array[,line,] <- partial_array[,line,]-0.25*(reversed[,11,line-1]+reversed[,16,line-1])
        }

      }
      else{
        reversed <- data_projection[,,,Time:1]
      
        partial_array[,1,] <- 0.25*(data_projection[,1,,1]+data_projection[,6,,1])
        for (line in 2:(Time/2+1)){
          partial_array[,line,] <- 0.25*(data_projection[,1,,line]+data_projection[,6,,line])
          partial_array[,line,] <- partial_array[,line,]-0.25*(reversed[,11,,line-1]+reversed[,16,,line-1])

        }
      }

      #convert the final array into two dimensional
      #merge the dimension time, gamma and momentum
      #leave the complex (real and imag) intact
      #real part will be equal to cf
      #complex part will be equal to icf
      tmpprod <- prod(dim(partial_array))
      dim(partial_array) <- c(2, tmpprod/2)
      data_final_real <- rbind(data_final_real, partial_array[1,])
      data_final_imag <- rbind(data_final_imag, partial_array[2,])

    }
    rhdf5::H5Fclose(h5f)

  }
  attr(data_final_real,"dimnames") <- NULL
  attr(data_final_imag,"dimnames") <- NULL


  cf <- cf_meta(nrObs=length(indices)*length(indices)*length(selections[[avail_baryon_types]]$interp),Time=Time,nrStypes=1,symmetrised=TRUE)
  cf$symmetrised=TRUE
  cf <- cf_orig(cf, cf=data_final_real,icf=data_final_imag)
  return(invisible(cf))

}

#' @export
#' @title read HDF5 unprojected contraction files in the Cyprus piNdiagramms format
#' @description The piNdiagramms function produces all types of baryon
#'              correlation function for isospin 3/2  for different momentum 
#               combinations, interpolating operators and source positions.
#'
#'              In this routine we read the types of baryon 4pt contractions
#'              specified by selections.
#'              For the moment here you can only define the 
#'                     a;type of baryon contraction (B,W,Z)
#'                     b;gamma structures (Cg5,C,Cg5g4,Cg4)
#'                     c;momentum  pi2     pf1    pf2
#                                (0,0,0) (0,0,0) (0,0,0)
#' @param selections Named list with names from the list 'B','W','Z'
#'                   The elements of this list are in turn expected
#'                   be data frames of the form
#'                     \tabular{rrrr}{
#'                       \strong{interp} \tab \strong{pi2x} \tab \strong{py} \tab \stron{pz} \cr
#'                       "Cg5"  \tab "0" \tab "1" \tab "1" \cr
#'                       "Cg1,Cg2,Cg3"  \tab "0" \tab "1" \tab "0" \cr
#'                       ...        \tab ... \tab ... \tab ...         
#'                     }
#'                   specifying the interpolating operators and momenta 
#'                   for each baryon type.
#' @param files Vector of strings, list of HDF5 files to be processed.
#'                    Currently only one element supported
#' @param Time Integer, time extent of the lattice.
#' @param verbose Boolean, output I/O time per file. Requires 'tictoc' package.
#' @return 
#'         raw_cf object containing all the correlation functions.
#'         Find it useful temporary for using the gevp

#' @export
cyprus_read_scattering_4pt_correlation <- function(selections, files, Time, use_parallel=TRUE, verbose = FALSE){
  rhdf5_avail <- requireNamespace("rhdf5")
  dplyr_avail <- requireNamespace("dplyr")
  if( verbose ){
    tictoc_avail <- requireNamespace("tictoc")
    if( !tictoc_avail ){
      stop("Time reporting requires the 'tictoc' package!")
    }
  }

  selected_diagramm_types <- names(selections)

  #we store the real parts and imaginary parts for
  #the different source positions separately
  data_final_real <- NULL
  data_final_imag <- NULL

  if( use_parallel ){
    parallel_avail <- requireNamespace("parallel")
    if( !parallel_avail ){
      stop("Running in parallel requires the 'parallel' package!")
    }
    lapply_fn <- parallel::mclapply
  } else {
    lapply_fn <- lapply
  }


  #loop on the list of files provided in the input
  loops_per_file <- parallel::mclapply(
    X = 1:length(files),
    FUN = function(ifile){
      f <- files[ifile]
      tictoc::tic(sprintf("Reading %s",f))

      #open the file with read only argument
      h5f <- rhdf5::H5Fopen(f, flags = "H5F_ACC_RDONLY")

      #checking whether the wanted diagramm type is available in the file

      h5filedatasetcontent <- rhdf5::h5ls(h5f)
      avail_diagramm_types <- FALSE
      for (line in h5filedatasetcontent$name){
        if( grepl(selected_diagramm_types, line) ){
         avail_diagramm_types <- TRUE
         break;
        }
      }
      if( !avail_diagramm_types  ){
        msg <- sprintf("Some selected diagramm types could not be found in %s:\n %s",
                       f,
                       do.call(paste, as.list( selected_diagramm_types[!avail_baryon_types] ) )
                     )
        stop(msg)
      }
      #determining a unique set of sequential momentum and check if they are all available
      all_pi2_momentum <- unique(data.frame(pi2x=selections[[selected_diagramm_types]]$pi2x,
                                          pi2y=selections[[selected_diagramm_types]]$pi2y,
                                          pi2z=selections[[selected_diagramm_types]]$pi2z))


      #First we extract the source positions contained in the file
    
      for (indexmom in 1:length(all_pi2_momentum$pi2x)){
        momstring <- sprintf("pi2=%d_%d_%d",all_pi2_momentum$pi2x[indexmom],
                                          all_pi2_momentum$pi2y[indexmom],
                                          all_pi2_momentum$pi2z[indexmom])
        if(length(unique(h5filedatasetcontent$group[grepl(momstring, h5filedatasetcontent$group)]))==0){
          msg <- sprintf("Some selected sequential momentum could not be found in %s:\n %s",
                       f,
                       momstring )
          stop(msg)
        }
      }

      tmpprod=length(selections[[selected_diagramm_types]]$pi2x)
      gammalist <- strsplit(as.character(selections[[selected_diagramm_types]]$interp[1]),",")[[1]]
      partial_array<- array(0,dim=c(2,Time/2+1,length(all_pi2_momentum$pi2x),length(gammalist)*length(gammalist)*tmpprod/length(all_pi2_momentum$pi2x)))
      #loop over all the sequential source momentum in the file
    
      for (indexmom in 1:length(all_pi2_momentum$pi2x)){

        seq_source_momenta <- c(all_pi2_momentum$pi2x[indexmom],
                                all_pi2_momentum$pi2y[indexmom],
                                all_pi2_momentum$pi2z[indexmom])
        filtered_selection <- filter(selections[[selected_diagramm_types]],pi2x==all_pi2_momentum$pi2x[indexmom],
                                                                           pi2y==all_pi2_momentum$pi2y[indexmom],
                                                                           pi2z==all_pi2_momentum$pi2z[indexmom])
        key <- cyprus_make_key_scattering4pt( h5filedatasetcontent$group[2], seq_source_momenta, "mvec" )

        # read the available momenta
        # array of 3 integer number
        data_mom <- h5_get_dataset(h5f, key)

        number_of_diagrams <- 4

        if (selected_diagramm_types == "B")
          number_of_diagrams <- 2


        for (diaindex in 1:number_of_diagrams){

          key <- cyprus_make_key_scattering4pt( h5filedatasetcontent$group[2], seq_source_momenta, sprintf("%s%d",selected_diagramm_types,diaindex ))

          # read the data
          data_corr <- h5_get_dataset(h5f, key)
          # convert it to a two-dimensional format, in such a way
          # that the first index corresponds to the gauge configuration (and source position)
          # and the second index corresponds to everything else
          #res <- matrix(data_corr, prod(dim(data_corr)[1:3]),dim(data_corr)[5])
          tmpprod <- prod(dim(data_corr))
          dim(data_corr)<- c(2,16,tmpprod/32/Time,Time)



          #looking for the momentum combinations
          #filtering out the momentum
          final_indices <- NULL
          for (differentcombinations in 1: length(filtered_selection$interp)){

            #determining the indices of momentum
            for(mom in 1:ncol(data_mom)){
              if ((all.equal(data_mom[,mom],
                              c(filtered_selection$pi2x[differentcombinations],
                                filtered_selection$pi2y[differentcombinations],
                                filtered_selection$pi2z[differentcombinations],
                                filtered_selection$pf1x[differentcombinations],
                                filtered_selection$pf1y[differentcombinations],
                                filtered_selection$pf1z[differentcombinations],
                                filtered_selection$pf2x[differentcombinations],
                                filtered_selection$pf2y[differentcombinations],
                                filtered_selection$pf2z[differentcombinations])
               ))==TRUE){
                momindex <- mom
                break;
              }
            }
            #getting the available gamma structures
            descrip <- rhdf5::h5readAttributes(h5f,key,"description")
            tmp <- strsplit(descrip$description,"/")
            tmp1<- strsplit(tmp[[1]][[4]],"}")
            tmp2 <- gsub(",\\{","",tmp1[[1]][[3]])
            gamma_source_list <- strsplit(tmp2,",")[[1]]
            gammalist <- strsplit(as.character(filtered_selection$interp[differentcombinations]),",")[[1]]

            #Determining the indices of the gamma structures
            indices <- NULL
            error_gamma <- TRUE
            for (line in 1:length(gammalist)){
              for (line2 in 1:length(gamma_source_list)){
                if (all.equal(gammalist[line], gamma_source_list[line2])==TRUE){
                  indices <- c(indices,line2);
                  error_gamma <- FALSE
                  break;
                }
              }
            }
            #if we have a gamma structure in the input that cannot be found in the
            # hdf5 file we return with error message
            if( error_gamma == TRUE ){
              msg <- sprintf("Some selected gamma structures could not be found in %s:\n %s",
                       f,
                       do.call(paste, as.list( gamma_source_list ) )
                     )
              stop(msg)
            }

            #Determining the indices of all the correlation functions
            #for example if the input is cg1,cg2,cg3 then we need the following
            #matrix
            #c( (cg5  ,cg5)  (cg5  ,c)   (cg5  ,cg5g4) (cg5  ,cg4) )
            #c( (c    ,cg5)  (c    ,c)   (c    ,cg5g4) (c    ,cg4) )
            #c( (cg5g4,cg5)  (cg5g4,c)   (cg5g4,cg5g4) (cg5g4,cg4) )
            #c( (cg4  ,cg5)  (cg4  ,c)   (cg4  ,cg5g4) (cg4  ,cg4) )

            #Note that here we do not project out, we return all the spin components
            #with real and imaginary part

            for (line1 in 1:length(indices)){
              for (line2 in 1:length(indices)){
                final_indices <- c(final_indices, (momindex-1)*length(gamma_source_list)*length(gamma_source_list)+(indices[line1]-1)*length(gamma_source_list)+(indices[line2]))
              }
            }
          }
          data_pp<- data_corr[,,final_indices,]

          data_unprojected<- data_corr[,,final_indices,]
          #Doing possible spin projection
          data_projection <- data_unprojected

          #Doing the symmetrization
          #C+-B=<0.25*Tr(1+-g4)*C>
          #Csymmetried=C+B(t)-C-B(T-t)

          #Obtaining C(T-t)
          if (length(final_indices)==1){
            reversed <- data_projection[,,Time:1]          
            partial_array[,1,indexmom,] <- partial_array[,1,indexmom,]+0.25*(data_projection[,1,1]+data_projection[,6,1])
            for (line in 2:(Time/2+1)){
              partial_array[,line,indexmom,] <- partial_array[,line,indexmom,] + 0.25*(data_projection[,1,line]+data_projection[,6,line])
              partial_array[,line,indexmom,] <- partial_array[,line,indexmom,] - 0.25*(reversed[,11,line-1]+reversed[,16,line-1])

            }
          }
          else{
            reversed <- data_projection[,,,Time:1]
            partial_array[,1,indexmom,] <- partial_array[,1,indexmom,]+0.25*(data_projection[,1,,1]+data_projection[,6,,1])
            for (line in 2:(Time/2+1)){
              partial_array[,line,indexmom,] <- partial_array[,line,indexmom,] + 0.25*(data_projection[,1,,line]+data_projection[,6,,line])
              partial_array[,line,indexmom,] <- partial_array[,line,indexmom,] - 0.25*(reversed[,11,,line-1]+reversed[,16,,line-1])
            }
          }

        } #end of loop for diagramm number

      } #end of loop for sequential momenta

      tmpprod <- prod(dim(partial_array))
      dim(partial_array) <- c(2, tmpprod/2)
      data_final_real <- rbind(data_final_real,partial_array[1,])
      data_final_imag <- rbind(data_final_imag,partial_array[2,])
      tmp_prod <- prod(dim(data_final_real))
      #dim(data_final_real) <- c(tmp_prod)
      #dim(data_final_imag) <- c(tmp_prod)


      rhdf5::H5Fclose(h5f)

      attr(data_final_real,"dimnames") <- NULL
      attr(data_final_imag,"dimnames") <- NULL
      tictoc::toc()

      cf <- cf_meta(nrObs=length(indices)*length(indices)*length(selections[[avail_diagramm_types]]$interp),Time=Time,nrStypes=1)
      cf$symmetrized <- TRUE
      cf <- cf_orig(cf, cf=data_final_real,icf=data_final_imag)
      return(cf) 

      }
  )
  return(loops_per_file)

}
