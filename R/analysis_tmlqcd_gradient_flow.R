#' analysis_tmlqcd_gradient_flow
#'
#' @param path string. path to data files
#' @param outputbasename string. basename of output files
#' @param basename string. basename of input files, for example "gradflow"
#' @param read.data boolean. Indicates whether to read data fresh from
#'   data files or to use `basename.raw.gradflow.Rdata` lying in the 
#'   present working directory instead
#' @param make_plots boolean. If set to `TRUE` plots will be generated
#' @param skip integer. number of measurements to skip
#' @param start integer. start value for MD time, this affects the MD time
#'   indicated in the plots
#' @param md_scalefac numeric. scale factor for the MD time, should be set to
#'   the stridelength (in units of trajectories or configurations)
#'   which was used to produce the gradient flow files, such that
#'   the distance between measurements can be interpreted
#'   correctly and the reported autocorrelation times scaled appropriately.
#' @param: md_idx_scalefac integer. scale factor for the measurement indices
#'   when, for instance, configurations are saved every n'th trajectory
#'   and subsequently the gradient flow measurement is performed on these
#'   configurations, the measurements will be indexed by the configuration
#'   index. `md_idx_scalefac` allows the measurements to be reindexed
#'   on all plots. For a run where every n'th trajectory was stored, 
#'   `md_idx_scalefac = n` would thus be used.
#' @param do_bootstrap boolean. If set to `TRUE`, the error analysis will
#'   be performed using the stationary bootstrap in addition to the Gamma method.
#'   To correctly account for autocorrelations, the block length is chosen
#'   automatically from the estimate of the integrated autocorrelation time 
#'   obtained through the Gamma method, choosing twice the longest observed
#'   autocorrelation time amongst all GF observables.
#'   The number of bootstrap samples is set to thrice the number of measurements.
#' @param plotsize numeric. Plot sidelength, this is passed to
#'   \code{tikz.init}.
#' @param scale_definition numeric. Default \eqn{0.3}. This is the value which is used to define
#'   the gluonic scales. For example, for \eqn{t_0}, \eqn{t^2 E = 0.3} is used and this parameter
#'   can be used to set this to any other value.
#'
#'
#' @description
#' function to analyse the gradient flow output files generated by
#' the tmLQCD software, see references.
#' =
#' The function generates a number of output files beyond plots, much like
#' \link{analysis_online}. In these, the following correspondences of variable
#' names to observables hold:
#'
#' \itemize{
#'   \item{traj: }{Configuration or trajectory number.}
#'   \item{t: }{Gradient flow time \eqn{t}.}
#'   \item{P: }{Average plaquette \eqn{<P>}.}
#'   \item{Eplaq: }{Energy density \eqn{E(t)} in the plaquette definition.}
#'   \item{Esym: }{Energy density \eqn{E(t)} in the clover definition.}
#'   \item{tsqEplaq: }{The observable \eqn{t^2 E(t)} used to define the scale \eqn{t_0} in the plaquette definition.}
#'   \item{tsqEsym: }{The observable \eqn{t^2 E(t)} used to define the scale \eqn{t_0} in the clover definition.}
#'   \item{Wsym: }{The observable \eqn{t d/dt (t^2 E(t))} used to define the scale \eqn{w_0} in the clover definition.}
#'   \item{Qsym: }{The topological charge \eqn{Q(t)} in the clover definition.}
#' }
#' 
#' The observables are analysed using the Gamma method (\link{uwerr}) and
#' the gradient flow scales \eqn{t_0} and \eqn{w_0} as well as various ratios
#' thereof are determined.
#'
#' The generated files are:
#' \itemize{
#'   \item{gradflow.summary.Rdata: }{Named list of data frames \code{gradflow_resultsum}.
#'         The names of the elements in this list  are based on \code{outputbasename}.
#'         The function attempts to read this file from the present working directory,
#'         so as to add to the list. If the file does not exist, it is created.
#'         If a name already exists in the list, it is overwritten. Each element
#'         contains the central value, statistical errors in positive and negative directions and
#'         the integrated autocorrelation time and its error for the observables "tsqEplaq", "tsqEsym"
#'         , "Wsym" and "Qsym_maxft", where the last corresponds to the topological
#'         charge at maximal flow time.}
#'   \item{%s.raw.gradflow.Rdata: }{The raw data read from the gradient flow files is written
#'         to this file with the pattern replaced by \code{outputbasename}. All of the observables
#'         listed above are written for all trajctories and flow times.}
#'   \item{%s.result.gradflow.Rdata: }{The results of the Gamma method analysis are written
#'         into this file with the pattern replaced by \code{outputbasename}. The saved object
#'         , \code{gradflow}, is a data frame with a column "t" and columns of the form
#'         "x.y", where "x" is the observable name as given in the list above and "y" is one
#'         of "value", "dvalue", "ddvalue", "tauint" and "dttauint". See \link{uwerr} for the meaning
#'         of each of these.}
#'   \item{%s.gradflow_results_per_meas.Rdata: }{Rather than performing the Gamma method analysis directly
#'         at each flow time, it is also possible to determine the gradient flow scales
#'         for each measurement and to extract the topological charge at the maximum flow time.
#'         The object \code{gradflow_results_per_meas} in this file, where the pattern is replaced
#'         with \code{outputbasename}, contains the results of this procedure as a data frame
#'         with the columns "traj", "tsqEplaq_per_meas", "tsqEsym_per_meas", "Wsym_per_meas" 
#'         and "Qsym_maxft_per_meas". Note: the object is a \link{tibble}.}
#' }
#'
#' @references
#' K. Jansen and C. Urbach, Comput.Phys.Commun. 180 (2009) 2717-2738

#' @return
#' Nothing is returned.
#'
#' @export
analysis_tmlqcd_gradient_flow <- function(path, outputbasename, basename="gradflow",
                                          read_files = TRUE, make_plots = FALSE, plotsize = 4,
                                          skip=0,
                                          md_scalefac=1, md_idx_scalefac=1,
                                          do_bootstrap = FALSE,
                                          scale_definition = 0.3) {

  dplyr_version_required <- "1.0.0"
  dplyr_avail <- requireNamespace("dplyr", versionCheck = list(op = ">=", version = dplyr_version_required))
  if( !dplyr_avail ){
    stop(sprintf("The 'dplyr' package in version >= %s is required to use this function!\n",
                 dplyr_version_required))
  }

  reshape2_avail <- requireNamespace("reshape2")
  if( !reshape2_avail ){
    stop("The 'reshape2' package is required to use this function!\n")
  }

  # much like for the analysis of online measurements, we store summary information                                                       # in the list "gradflow_resultsum" with elements named by "outputbasename"
  # such that when the analysis is rerun, the entries are replaced
  gf_summaries_db_file <- "gradflow.summary.Rdata"
  gradflow_resultsum <- list()
  if(file.exists(gf_summaries_db_file)){
    message("Loading gradient flow summary results database from ", gf_summaries_db_file, "\n")
    load(gf_summaries_db_file)
  }

  raw_gradflow <- read_tmlqcd_gf_data(path = path, skip = skip,
                                      basename = basename, outputbasename = outputbasename,
                                      read_files = read_files)

  have_Qsym <- "Qsym" %in% colnames(raw_gradflow)

  gf_scales <- lapply(
      X = define_gf_scales_plan(),
      FUN = function(gf_scale){
        # we need to reshape the tidy data frame into a 2D form for each observable
        gf_obs_vars <- c('t', 'traj', gf_scale$obs)
        gf_obs_arr <- reshape2::acast(data = dplyr::select(raw_gradflow, dplyr::one_of(gf_obs_vars)),
                                      value.var = gf_obs_vars[3],
                                      formula = "traj ~ t")

        gf_obs_uwerr <- apply_uwerrprimary(X = gf_obs_arr, S = 1.5) 
        gf_scale_uwerr <- uwerrderived(f = gf_find_intersect,
                                       data = gf_obs_arr,
                                       time = dimnames(gf_obs_arr)[[2]],
                                       intersection = scale_definition)

        gf_scale_ratios_uwerr <- list()
        if( !any(is.na(gf_scale$ratios)) ){
          for( ratio_i in 1:length(gf_scale$ratios) ){
            ratio_denom_vars <- c('t', 'traj', gf_scale$ratio_denom_obs[ratio_i])
            ratio_name <- gf_scale$ratios[ratio_i]

            gf_ratio_denom_obs_arr <- reshape2::acast(data = dplyr::select(raw_gradflow, dplyr::one_of(ratio_denom_vars)),
                                                      value.var = ratio_denom_vars[3],
                                                      formula = "traj ~ t")
            gf_scale_ratios_uwerr[[ratio_name]] <- 
              uwerrderived(f = gf_scale$ratio_funs[[ratio_i]],
                           data = cbind(gf_obs_arr, gf_ratio_denom_obs_arr),
                           time = dimnames(gf_obs_arr)[[2]],
                           intersection1 = scale_definition,
                           intersection2 = scale_definition)
          }
        } else {
          gf_scale_ratios_uwerr <- NA
        }

        return(
          list(obs = gf_obs_uwerr,
               scale = gf_scale_uwerr,
               ratios = gf_scale_ratios_uwerr)
        )
      }
    )
 
  # find the maximum integrated autocorrelation time amongst the scales 
  max_scale_tauint <- 0.5
  for( i in 1:length(gf_scales) ){
    if( max_scale_tauint < gf_scales[[i]]$scale$tauint ){
      max_scale_tauint <- gf_scales[[i]]$scale$tauint
    }
  }
  # and use it to set the average block length for bootstrapping the scale determination
  # and the calculation of the scale ratios
  boot.l <- 2*ceiling(max_scale_tauint)
  boot.R <- 3*length(unique(raw_gradflow$traj))

  if( do_bootstrap ){
    gf_scales_bs <- bootstrap_gf_scales_and_ratios(
      raw_gradflow = raw_gradflow,
      boot.R = boot.R,
      boot.l = boot.l)
  } else {
    # build the minimum structure in case we forego the bootstrap
    gf_scales_bs <- na_bs_gf_scales_and_ratios()
  }
  
  res <- list(have_Qsym = have_Qsym,
              raw_gradflow = raw_gradflow,
              uw = gf_scales,
              bs = gf_scales_bs)
  res[["md_scalefac"]] <- md_scalefac
  res[["md_idx_scalefac"]] <- md_idx_scalefac

  if( have_Qsym ){
    Qsym_arr <- reshape2::acast(data = dplyr::select(raw_gradflow, traj, t, Qsym),
                                value.var = "Qsym",
                                formula = "traj ~ t")
    Qsym_uwerr <- apply_uwerrprimary(X = Qsym_arr, S = 1.5)

    res[["Qsym_uwerr"]] <- Qsym_uwerr
  }


  # now we interpolate all observables in the gradient flow to the flow times
  # corresponding to the various gradient flow scales
  target_ts <- list()
  target_ts[["t0plaq"]] <- list(name = "t0plaq", val = (gf_scales$sqrt_t0plaq$scale$value)^2)
  target_ts[["t0sym"]] <- list(name = "t0sym", val = (gf_scales$sqrt_t0sym$scale$value)^2)
  target_ts[["w0"]] <- list(name = "w0", val = (gf_scales$w0$scale$value)^2 )
  target_ts[["tmax"]] <- list(name = "tmax", val = max(raw_gradflow$t) )
  res[["interpolations"]] <- gf_interpolate(raw_gradflow, target_ts)
  res[["t"]] <- sort(unique(raw_gradflow$t))
  
  res[["summary"]] <- summarise_gf_results(res, md_scalefac)

  if(make_plots) gf_make_plots(res, outputbasename, plotsize, scale_definition)

	gradflow_resultsum[[outputbasename]] <- res$summary
  save(gradflow_resultsum, file=gf_summaries_db_file)

  gf_analysis <- res
  save(gf_analysis, file = sprintf("%s_gf_analysis.Rdata", outputbasename))

  return(invisible(res))
}

gf_plot_flow <- function(obs_uwerr, tlim, intersection, ...){
  stopifnot(length(tlim) == 2)

  x <- as.numeric(rownames(obs_uwerr))
  y <- obs_uwerr$value
  ymin <- y - obs_uwerr$dvalue
  ymax <- y + obs_uwerr$dvalue

  # empty plot type to set the limits and axis labels 
  plot(x = x,
       y = y,
       type = 'n',
       xlab = "$t/a^2$",
       las = 1,
       xlim = tlim,
       ...)
  draw_errorband(x = x, ymin = ymin, ymax = ymax, col = "red", alpha = 0.6)
  if( !missing(intersection) ){
    rect(xleft = intersection$tval - intersection$tse,
         xright = intersection$tval + intersection$tse,
         ybottom = -10,
         ytop = intersection$obsval,
         col = col2rgba(col = "blue", alpha = 0.6),
         border = NA)
    abline(h = intersection$obsval)
    abline(v = intersection$tval)
    legend(x = "topleft",
           lty = 1,
           col = "blue",
           bty = 'n',
           cex = 0.8,
           legend = sprintf("$%s = %s$",
                            intersection$label,
                            tex.catwitherror(x = intersection$tval,
                                             dx = intersection$tse,
                                             digits = 2,
                                             with.dollar = FALSE)))
  }
  # all lines on top of the error bands
  lines(x = x, y = y)
}

add_tauint_legend <- function(tauint, dtauint, obslabel){
  legend(x = "topleft", bty = 'n', pch = NA, lty = 1, col = "red", cex = 0.8,
         legend = sprintf("$\\tau_{\\mathrm{int}}($ %s $) = %s$ traj.",
                          obslabel,
                          tex.catwitherror(x = tauint,
                                           dx = dtauint,
                                           digits = 2,
                                           with.dollar = FALSE, with.cdot = FALSE)
                         )
        ) 
}

gf_make_plots <- function(gf_analysis_results, outputbasename, plotsize, scale_definition = 0.3){
  dplyr_avail <- requireNamespace("dplyr")
  if( !dplyr_avail ){
    stop("The 'dplyr' package is required to use this function!\n")
  }
  
  tikzfiles <- tikz.init(basename = sprintf("%s.gradflow", outputbasename), 
                         width = plotsize, height = plotsize)

  # some bookkeeping to loop over the different scales
  loop_plan <- list()
  loop_plan[[length(loop_plan)+1]] <- list(name = "sqrt_t0plaq",
                                           intersection_label = "t_0^{\\mathrm{plaq}}/a^2",
                                           interp_name = "t0plaq",
                                           interp_obs = "tsqEplaq_t0plaq",
                                           interp_label_suffix = "$|_{t = t_0^{\\mathrm{plaq}}}$")
  loop_plan[[length(loop_plan)+1]] <- list(name = "sqrt_t0sym",
                                           intersection_label = "t_0^{\\mathrm{sym}}/a^2",
                                           interp_name = "t0sym",
                                           interp_obs = "tsqEsym_t0sym",
                                           interp_label_suffix = "$|_{t = t_0^{\\mathrm{sym}}}$")
  loop_plan[[length(loop_plan)+1]] <- list(name = "w0",
                                           intersection_label = "(w_0/a)^2",
                                           interp_name = "w0",
                                           interp_obs = "Wsym_w0",
                                           interp_label_suffix = "$|_{t = (w_0^{\\mathrm{sym}})^2}$")

  for( iter in loop_plan ){
    scale_sq <- gf_analysis_results$uw[[iter$name]]$scale$value^2
    scale_sq_se <- 2*gf_analysis_results$uw[[iter$name]]$scale$value *
                     gf_analysis_results$uw[[iter$name]]$scale$dvalue

    obslabel <- dplyr::filter(gf_analysis_results$summary, name == iter$name)$obslabel

    # plot the flow evolution of the observable for the scale in question
    gf_plot_flow(obs_uwerr = gf_analysis_results$uw[[iter$name]]$obs,
                 tlim = c(0, 1.33 * scale_sq),
                 intersection = list(obsval = scale_definition, tval = scale_sq, 
                                     tse = scale_sq_se, label = iter$intersection_label),
                 ylim = c(0, 1.33 * scale_definition),
                 ylab = obslabel
                 )

    # now we plot the observable at the flow time corresponding to the scale in question
    # being careful about the relationship between the md time indexing and its relationship
    # to actual trajectories 
    interp_dat <- data.frame(t = gf_analysis_results$interpolations[[iter$interp_name]]$md_idx *
                                   gf_analysis_results$md_idx_scalefac,
                             y =  gf_analysis_results$interpolations[[iter$interp_name]][[iter$interp_obs]])
    interp_label <- paste(obslabel, iter$interp_label_suffix)

    interp_uw <- plot_timeseries(dat = interp_dat, ylab = interp_label, titletext = "")
    # the last plot is always the tauint estimator, so we can easily add a legend here
    # we need to be careful because of the relationship of measurement indexing, their
    # frequency and actual MD time
    add_tauint_legend(tauint = gf_analysis_results$md_scalefac * interp_uw["tauint",1],
                      dtauint = gf_analysis_results$md_scalefac * interp_uw["dtauint",1],
                      obslabel = interp_label)
  }
  if( gf_analysis_results$have_Qsym ){
    obslabel <- dplyr::filter(gf_analysis_results$summary, name == "Qsym_tmax")$obslabel

    # plot the gradient flow evolution of the topological charge
    gf_plot_flow(obs_uwerr = gf_analysis_results$Qsym_uwerr,
                 tlim = c(0.01, max(gf_analysis_results$t)),
                 ylim = range(c(gf_analysis_results$Qsym_uwerr$value - gf_analysis_results$Qsym_uwerr$dvalue,
                                gf_analysis_results$Qsym_uwerr$value + gf_analysis_results$Qsym_uwerr$dvalue)),
                 log = 'x',
                 ylab = obslabel)

    # and the MD history of the topological charge at flow time w_0^2
    md_label <- paste(obslabel, "$|_{t = (w_0^{\\mathrm{sym}}/a)^2}$")
    Qsym_w0_uw <- plot_timeseries(dat = data.frame(y = gf_analysis_results$interpolations$w0$Qsym_w0,
                                                   t = gf_analysis_results$md_idx_scalefac * 
                                                       unique(gf_analysis_results$raw_gradflow$traj)),
                                  ylab = md_label, titletext = "")
    add_tauint_legend(tauint = gf_analysis_results$md_scalefac * Qsym_w0_uw['tauint',1],
                      dtauint = gf_analysis_results$md_scalefac * Qsym_w0_uw['dtauint',1],
                      obslabel = md_label)

    # now extract and plot the MD history of the topoligical charge at maximum flow time
    Qsym_tmax_dat <- dplyr::transmute(  
                       dplyr::select(
                         dplyr::filter(gf_analysis_results$raw_gradflow, t == max(t)),
                         traj, Qsym
                       ),
                       t = gf_analysis_results$md_idx_scalefac * traj,
                       y = Qsym
                     )

    md_label <- paste(obslabel, "$|_{t = t_{\\mathrm{max}}}$")
    Qsym_tmax_uw <- plot_timeseries(dat = Qsym_tmax_dat, ylab = md_label, titletext = "")
    add_tauint_legend(tauint = gf_analysis_results$md_scalefac * Qsym_tmax_uw["tauint",1],
                      dtauint = gf_analysis_results$md_scalefac * Qsym_tmax_uw["dtauint",1],
                      obslabel = md_label)
  }

  tikz.finalize(tikzfiles)
}

gf_interpolate <- function(raw_gradflow, target_ts){
  dplyr_avail <- requireNamespace("dplyr")
  if( !dplyr_avail ){
    stop("The 'dplyr' package is required to use this function!\n")
  }
  
  gf_tseries <- tseries_orig(data = dplyr::rename(raw_gradflow, md_idx = traj),
                             explanatory_vars = c("t"))

  all_obs <- dplyr::setdiff(colnames(gf_tseries$data), c("t", "md_idx"))

  res <- lapply(
    X = target_ts,
    FUN = function(target_t){
      reduce_plan <- lapply(
        X = all_obs,
        FUN = function(obs){
          exp_string <- sprintf("approx(x = t, y = %s, xout = %f)$y",
                                obs, target_t$val)
          parse(text = exp_string)
        }
      )
      names(reduce_plan) <- sprintf("%s_%s", all_obs, rep(target_t$name, times = length(all_obs)))

      apply_reduce_plan.tseries(ts = gf_tseries, reduce_vars = c("t"), reduce_plan)$data
    }
  )
  return(res)
}

summarise_gf_results <- function(gf_analysis_results, md_scalefac) {
  sum_res <- rbind(
    data.frame(name = "sqrt_t0plaq",
               label = "$\\sqrt{t_0^\\mathrm{plaq}}/a$",
               obslabel = "$\\langle t^2 E_{\\mathrm{plaq}}(t) \\rangle$",
               val = gf_analysis_results$uw$sqrt_t0plaq$scale$value,
               dval = gf_analysis_results$uw$sqrt_t0plaq$scale$dvalue,
               dvalbs = gf_analysis_results$bs$scales$se$sqrt_t0plaq,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0plaq$scale$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0plaq$scale$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0plaq$scale$ddvalue),
    data.frame(name = "sqrt_t0sym",
               label = "$\\sqrt{t_0^\\mathrm{sym}}/a$",
               obslabel = "$\\langle t^2 E_{\\mathrm{sym}}(t) \\rangle$",
               val = gf_analysis_results$uw$sqrt_t0sym$scale$value,
               dval = gf_analysis_results$uw$sqrt_t0sym$scale$dvalue,
               dvalbs = gf_analysis_results$bs$scales$se$sqrt_t0sym,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$scale$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$scale$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0sym$scale$ddvalue),
    data.frame(name = "w0",
               label = "$w_0/a$",
               obslabel = "$\\langle t \\frac{d}{dt} [ t^2 E_{\\mathrm{sym}}(t) ]\\rangle$",
               val = gf_analysis_results$uw$w0$scale$value,
               dval = gf_analysis_results$uw$w0$scale$dvalue,
               dvalbs = gf_analysis_results$bs$scales$se$w0,
               tauint = md_scalefac*gf_analysis_results$uw$w0$scale$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$w0$scale$dtauint,
               ddval = gf_analysis_results$uw$w0$scale$ddvalue),
    data.frame(name = "t0plaq_ov_w0",
               label = "$t_0^{\\mathrm{plaq}} / (a w_0)$",
               obslabel = NA,
               val = gf_analysis_results$uw$sqrt_t0plaq$ratios$t0plaq_ov_w0$value,
               dval = gf_analysis_results$uw$sqrt_t0plaq$ratios$t0plaq_ov_w0$dvalue,
               dvalbs = gf_analysis_results$bs$ratios$se$t0plaq_ov_w0,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0plaq$ratios$t0plaq_ov_w0$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0plaq$ratio$t0plaq_ov_w0$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0plaq$ratios$t0plaq_ov_w0$ddvalue),
    data.frame(name = "t0sym_ov_w0",
               label = "$t_0^{\\mathrm{sym}} / (a w_0)$",
               obslabel = NA,
               val = gf_analysis_results$uw$sqrt_t0sym$ratios$t0sym_ov_w0$value,
               dval = gf_analysis_results$uw$sqrt_t0sym$ratios$t0sym_ov_w0$dvalue,
               dvalbs = gf_analysis_results$bs$ratios$se$t0sym_ov_w0,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$ratios$t0sym_ov_w0$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$ratio$t0sym_ov_w0$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0sym$ratios$t0sym_ov_w0$ddvalue),
    data.frame(name = "sqrt_t0plaq_ov_w0",
               label = "$\\sqrt{t_0^{\\mathrm{plaq}}} / w_0$",
               obslabel = NA,
               val = gf_analysis_results$uw$sqrt_t0plaq$ratios$sqrt_t0plaq_ov_w0$value,
               dval = gf_analysis_results$uw$sqrt_t0plaq$ratios$sqrt_t0plaq_ov_w0$dvalue,
               dvalbs = gf_analysis_results$bs$ratios$se$sqrt_t0plaq_ov_w0,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0plaq$ratios$sqrt_t0plaq_ov_w0$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0plaq$ratios$sqrt_t0plaq_ov_w0$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0plaq$ratios$sqrt_t0plaq_ov_w0$ddvalue),
    data.frame(name = "sqrt_t0sym_ov_w0",
               label = "$\\sqrt{t_0^{\\mathrm{sym}}} / w_0$",
               obslabel = NA,
               val = gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_w0$value,
               dval = gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_w0$dvalue,
               dvalbs = gf_analysis_results$bs$ratios$se$sqrt_t0sym_ov_w0,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_w0$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$ratio$sqrt_t0sym_ov_w0$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_w0$ddvalue),
    data.frame(name = "sqrt_t0sym_ov_sqrt_t0plaq",
               label = "$\\sqrt{t_0^{\\mathrm{sym}}} / \\sqrt{t_0^{\\mathrm{plaq}}}$",
               obslabel = NA,
               val = gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_sqrt_t0plaq$value,
               dval = gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_sqrt_t0plaq$dvalue,
               dvalbs = gf_analysis_results$bs$ratios$se$sqrt_t0sym_ov_sqrt_t0plaq,
               tauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_sqrt_t0plaq$tauint,
               dtauint = md_scalefac*gf_analysis_results$uw$sqrt_t0sym$ratio$sqrt_t0sym_ov_sqrt_t0plaq$dtauint,
               ddval = gf_analysis_results$uw$sqrt_t0sym$ratios$sqrt_t0sym_ov_sqrt_t0plaq$ddvalue)

  )
  if( gf_analysis_results$have_Qsym ){
    Qsym_w0_uwerr <- uwerrprimary(data = gf_analysis_results$interpolations$w0$Qsym_w0, S = 1.5, pl = FALSE)

    tmax_idx <- nrow(gf_analysis_results$Qsym_uwerr)
    sum_res <- rbind(sum_res,
                     data.frame(name = "Qsym_w0",
                                label = "$Q_{\\mathrm{sym}}(t=w_0^2)$",
                                obslabel = paste("$\\langle \\varepsilon_{\\mu \\nu \\rho \\gamma}^{\\mathrm{(eucl)}}",
                                                 "\\mathrm{Tr} [F_{\\mu \\nu} F_{\\rho \\gamma}](t) \\rangle$"),
                                val = Qsym_w0_uwerr$value,
                                dval = Qsym_w0_uwerr$dvalue,
                                dvalbs = NA,
                                tauint = md_scalefac*Qsym_w0_uwerr$tauint,
                                dtauint = md_scalefac*Qsym_w0_uwerr$dtauint,
                                ddval = Qsym_w0_uwerr$ddvalue),
                     data.frame(name = "Qsym_tmax",
                                label = "$Q_{\\mathrm{sym}}(t_{\\mathrm{max}})$",
                                obslabel = paste("$\\langle \\varepsilon_{\\mu \\nu \\rho \\gamma}^{\\mathrm{(eucl)}}",
                                                 "\\mathrm{Tr} [F_{\\mu \\nu} F_{\\rho \\gamma}](t) \\rangle$"),
                                val = gf_analysis_results$Qsym_uwerr$value[tmax_idx],
                                dval = gf_analysis_results$Qsym_uwerr$dvalue[tmax_idx],
                                dvalbs = NA,
                                tauint = md_scalefac*gf_analysis_results$Qsym_uwerr$tauint[tmax_idx],
                                dtauint = md_scalefac*gf_analysis_results$Qsym_uwerr$dtauint[tmax_idx],
                                ddval = gf_analysis_results$Qsym_uwerr$ddvalue[tmax_idx])
                     )
  }
  return(sum_res)
}

#' return NAs for quantiies in `bootstrap_gf_scales_and_ratios`
na_bs_gf_scales_and_ratios <- function() {
  ratios <- list()
  scales <- list()
  ratios$names <- c("t0plaq_ov_w0", "t0sym_ov_w0", "sqrt_t0plaq_ov_w0", "sqrt_t0sym_ov_w0", "sqrt_t0sym_ov_sqrt_t0plaq")
  scales$names <- c("sqrt_t0plaq", "sqrt_t0sym", "w0")
  ratios$central <- lapply(X = ratios$names, FUN = function(x) NA)
  names(ratios$central) <- ratios$names
  ratios$se <- ratios$central
  scales$central <- lapply(X = scales$names, FUN = function(x) NA)
  names(scales$central) <- scales$names
  scales$se <- scales$central

  return( list(scales = scales, ratios = ratios) )
}

#' bootstrap gradient flow scale determinations
bootstrap_gf_scales_and_ratios <- function(raw_gradflow, boot.l, boot.R, seed = 12345, scale_definition = 0.3){
  dplyr_avail <- requireNamespace("dplyr")
  if( !dplyr_avail ){
    stop("The 'dplyr' package is required to use this function!\n")
  }

  # we use this common boot.l to bootstrap both the determination of the numerator
  # and the denominator
  gf_data <- dplyr::rename(dplyr::select(raw_gradflow, t, traj, Wsym, tsqEplaq, tsqEsym),
                           md_idx = traj)

  gf_obs_tseries <- bootstrap.tseries(
    .tseries = tseries_orig(data = gf_data, explanatory_vars = c("t")),
    boot.R = boot.R,
    boot.l = boot.l,
    seed = seed,
    sim = 'geom',
    endcorr = TRUE,
    serial = FALSE,
    progress = TRUE)

  # let's begin by determining the scales
  plan <- list()
  plan[["sqrt_t0plaq"]] <- expression( sqrt( approx(x = tsqEplaq, y = t, xout = scale_definiton)$y ) )
  plan[["sqrt_t0sym"]] <- expression( sqrt( approx(x = tsqEsym, y = t, xout = scale_definition)$y ) )
  plan[["w0"]] <- expression( sqrt( approx(x = Wsym, y = t, xout = scale_definition)$y ) )

  gf_scales <- apply_reduce_plan.tseries(ts = gf_obs_tseries,
                                         reduce_vars = c("t"),
                                         plan = plan)
 
  print(gf_scales)
  readline()

  # and then the ratios
  plan <- list()
  plan[["t0plaq_ov_w0"]] <- expression( sqrt_t0plaq^2 / w0 )
  plan[["t0sym_ov_w0"]] <- expression( sqrt_t0sym^2 / w0 )
  plan[["sqrt_t0plaq_ov_w0"]] <- expression( sqrt_t0plaq / w0 )
  plan[["sqrt_t0sym_ov_w0"]] <- expression( sqrt_t0sym / w0 )
  plan[["sqrt_t0sym_ov_sqrt_t0plaq"]] <- expression( sqrt_t0sym / sqrt_t0plaq )
  gf_scale_ratios <- apply_transmute_plan.tseries(ts = gf_scales,
                                                  plan = plan)

  return(invisible(
    list(scales = gf_scales, ratios = gf_scale_ratios)
  ))
}


#' define plan for gradient flow scales determination
define_gf_scales_plan <- function(){
  gf_scales_plan <- list()
  gf_scales_plan[["sqrt_t0plaq"]] <- list(obs = "tsqEplaq", scale = "sqrt_t0plaq",
                                          ratios = c("t0plaq_ov_w0", "sqrt_t0plaq_ov_w0"), 
                                          ratio_denom_obs = c("Wsym", "Wsym"),
                                          ratio_funs = list(gf_scale_sq_ov_gf_scale,
                                                            gf_scale_ov_gf_scale))

  gf_scales_plan[["sqrt_t0sym"]] <-  list(obs = "tsqEsym", scale = "sqrt_t0sym",
                                          ratios = c("t0sym_ov_w0", "sqrt_t0sym_ov_w0", "sqrt_t0sym_ov_sqrt_t0plaq"),
                                          ratio_denom_obs = c("Wsym", "Wsym", "tsqEplaq"),
                                          ratio_funs = list(gf_scale_sq_ov_gf_scale,
                                                            gf_scale_ov_gf_scale,
                                                            gf_scale_ov_gf_scale))

  gf_scales_plan[["w0"]] <-          list(obs = "Wsym", scale = "w0", 
                                          ratios = NA, ratio_num_obs = NA, ratio_denom_obs = NA, ratio_funs = NA)

  return(gf_scales_plan)
}

#' determine intersection point of a gradient flow observable
#'
#' @param data Numeric vector of length corresponding to the number
#' of primary observables. This would be a single (possibly blocked) measurement
#' of a gradient flowed observable at all flow times. There's an implicit
#' assumption that `data` is monotonic in the relevant region.
#' @param time Numeric vector giving the values of \eqn{t/a^2} that the observable
#' in \code{data} has been measured at.
#' @param Numeric, intersection point to be determined. Usually this is \eqn{0.3},
#' which is also the default value.
#'
#' @return
#' A single numeric corresponding to the point where `data` as a function of `time`
#' intersects `intersection`, we return the square root of the gradient flow scale.
gf_find_intersect <- function(data, time, intersection = 0.3){
  stopifnot(length(data) == length(time))
  sqrt( approx(x = data, y = time, xout = intersection)$y )
}

#' determine the ratio of the square of a gf scale and the value of another
#'
#' @param data Numeric vector of length corresponding to twice the number
#' of primary observables. This would be a single (possibly blocked) measurement
#' of two gradient flowed observables at all flow times. This might be 
#' \eqn{ t^2 E(t) } and \eqn{ t \frac{d}{dt} ( t^2 E(t) ) }, for example. There's
#' an implicit assumption that both observables are monotonic in the relevant region.
#' The 'first' observable is in the first \code{length{time}} elements, while
#' the 'second' observable is expected to be in the last \code{length{time}} elements.
#' @param time Numeric vector giving the values of \eqn{t/a^2} that the observable
#' in \code{data} has been measured at.
#' @param intersection1, intersection2 Numeric, intersection points to be determined for
#' the first and second observables, respectively. 
#' Usually this is \eqn{0.3}, which is also taken as the default value.
#'
#' @return
#' A single numeric value corresponding to the ratio of the flow time where the flow time of
#' the first observable intersects `intersection1` and the square root of the flow time at
#' which the second observable intersects `intersection2`.
gf_scale_sq_ov_gf_scale <- function(data, time, intersection1 = 0.3, intersection2 = 0.3){
  stopifnot(length(data) == 2*length(time))
  (gf_find_intersect(data = data[1:length(time)], 
                    time = time, 
                    intersection = intersection1))^2 /
    gf_find_intersect(data = data[(length(time)+1):(2*length(time))],
                            time = time,
                            intersection = intersection2)
}

#' determine the ratio of the square of a gf scale and the square of another
#'
#' @param data Numeric vector of length corresponding to twice the number
#' of primary observables. This would be a single (possibly blocked) measurement
#' of two gradient flowed observables at all flow times. This might be 
#' \eqn{ t^2 E(t) } and \eqn{ t \frac{d}{dt} ( t^2 E(t) ) }, for example. There's
#' an implicit assumption that both observables are monotonic in the relevant region.
#' The 'first' observable is in the first \code{length{time}} elements, while
#' the 'second' observable is expected to be in the last \code{length{time}} elements.
#' @param time Numeric vector giving the values of \eqn{t/a^2} that the observable
#' in \code{data} has been measured at.
#' @param intersection1, intersection2 Numeric, intersection points to be determined for
#' the first and second observables, respectively. 
#' Usually this is \eqn{0.3}, which is also taken as the
#' default value.
#'
#' @return
#' A single numeric value corresponding to the ratio of the flow time where
#' the first observable intersects `intersection1` and the flow time at
#' which the second observable intersects `intersection2`.
gf_scale_sq_ov_gf_scale_sq <- function(data, time, intersection1 = 0.3, intersection2 = 0.3){
  stopifnot(length(data) == 2*length(time))
  (gf_find_intersect(data = data[1:length(time)], 
                    time = time, 
                    intersection = intersection1))^2 /
    gf_find_intersect(data = data[(length(time)+1):(2*length(time))],
                            time = time,
                            intersection = intersection2)^2
}

#' determine the ratio of one gf scale and another
#'
#' @param data Numeric vector of length corresponding to twice the number
#' of primary observables. This would be a single (possibly blocked) measurement
#' of two gradient flowed observables at all flow times. This might be 
#' \eqn{ t^2 E(t) } and \eqn{ t \frac{d}{dt} ( t^2 E(t) ) }, for example. There's
#' an implicit assumption that both observables are monotonic in the relevant region.
#' The 'first' observable is in the first \code{length{time}} elements, while
#' the 'second' observable is expected to be in the last \code{length{time}} elements.
#' @param time Numeric vector giving the values of \eqn{t/a^2} that the observable
#' in \code{data} has been measured at.
#' @param intersection1, intersection2 Numeric, intersection points to be determined for
#' the first and second observables, respectively. 
#' Usually this is \eqn{0.3}, which is also taken as the
#' default value.
#'
#' @return
#' A single numeric value corresponding to the ratio of the square root of flow time where
#' the first observable intersects `intersection1` and the square root of the flow time at
#' which the second observable intersects `intersection2`.
gf_scale_ov_gf_scale <- function(data, time, intersection1 = 0.3, intersection2 = 0.3){
  stopifnot(length(data) == 2*length(time))
  (gf_find_intersect(data = data[1:length(time)], 
                    time = time, 
                    intersection = intersection1)) /
    gf_find_intersect(data = data[(length(time)+1):(2*length(time))],
                            time = time,
                            intersection = intersection2)
}

#' helper function to read tmlqcd gradient flow data
#'
#' @param path directory name which contains gradient flow measurement files in the tmlqcd
#' format
#'
#' @param skip Integer, number of measurements to be skipped.
#' @param basename String, basename of the data, for example "gradflow".
#' @param outputbasename Stirng, this function will create an output file of the form "%s.raw_gradflow.Rdata".
#' in the present working directory. This parameter sets "%s".
#' @param read_files Boolean, whether to reread the raw data.
#'
#' @return Gradient flow data as produced by \code{\link{read_tmlqcd_gradflow}}.
#' 
read_tmlqcd_gf_data <- function(path, skip, basename, outputbasename, read_files){
  save_filename <- sprintf("%s.raw_gradflow.Rdata", outputbasename)
  if(read_files){
    raw_gradflow <- read_tmlqcd_gradflow(path = path, skip = skip, basename = basename)
    save(raw_gradflow, file = save_filename, compress = FALSE)
  } else {
    warning(sprintf(paste("Warning, reading data from %s, if the number of measurements has changed,",
                          "set `read_files = TRUE` to reread the actualy output files\n"),
                    save_file)
    )
    load(save_file)
  }
  return(raw_gradflow)
}
